{"ts":1373642035008,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/**\n * AngularUI - The companion suite for AngularJS\n * @version v0.4.0 - 2013-02-15\n * @link http://angular-ui.github.com\n * @license MIT License, http://www.opensource.org/licenses/MIT\n */\n\n\nangular.module('ui.config', []).value('ui.config', {});\nangular.module('ui.filters', ['ui.config']);\nangular.module('ui.directives', ['ui.config']);\nangular.module('ui', ['ui.filters', 'ui.directives', 'ui.config']);\n\n/**\n * Animates the injection of new DOM elements by simply creating the DOM with a class and then immediately removing it\n * Animations must be done using CSS3 transitions, but provide excellent flexibility\n *\n * @todo Add proper support for animating out\n * @param [options] {mixed} Can be an object with multiple options, or a string with the animation class\n *    class {string} the CSS class(es) to use. For example, 'ui-hide' might be an excellent alternative class.\n * @example <li ng-repeat=\"item in items\" ui-animate=\" 'ui-hide' \">{{item}}</li>\n */\nangular.module('ui.directives').directive('uiAnimate', ['ui.config', '$timeout', function (uiConfig, $timeout) {\n  var options = {};\n  if (angular.isString(uiConfig.animate)) {\n    options['class'] = uiConfig.animate;\n  } else if (uiConfig.animate) {\n    options = uiConfig.animate;\n  }\n  return {\n    restrict: 'A', // supports using directive as element, attribute and class\n    link: function ($scope, element, attrs) {\n      var opts = {};\n      if (attrs.uiAnimate) {\n        opts = $scope.$eval(attrs.uiAnimate);\n        if (angular.isString(opts)) {\n          opts = {'class': opts};\n        }\n      }\n      opts = angular.extend({'class': 'ui-animate'}, options, opts);\n\n      element.addClass(opts['class']);\n      $timeout(function () {\n        element.removeClass(opts['class']);\n      }, 20, false);\n    }\n  };\n}]);\n\n\n/*\n*  AngularJs Fullcalendar Wrapper for the JQuery FullCalendar\n*  API @ http://arshaw.com/fullcalendar/ \n*  \n*  Angular Calendar Directive that takes in the [eventSources] nested array object as the ng-model and watches (eventSources.length + eventSources[i].length) for changes. \n*       Can also take in multiple event urls as a source object(s) and feed the events per view.\n*       The calendar will watch any eventSource array and update itself when a delta is created  \n*       An equalsTracker attrs has been added for use cases that would render the overall length tracker the same even though the events have changed to force updates.\n*\n*/\n\nangular.module('ui.directives').directive('uiCalendar',['ui.config', '$parse', function (uiConfig,$parse) {\n     uiConfig.uiCalendar = uiConfig.uiCalendar || {};       \n     //returns calendar     \n     return {\n        require: 'ngModel',\n        restrict: 'A',\n          link: function(scope, elm, attrs, $timeout) {\n            var sources = scope.$eval(attrs.ngModel);\n            var tracker = 0;\n            /* returns the length of all source arrays plus the length of eventSource itself */\n            var getSources = function () {\n              var equalsTracker = scope.$eval(attrs.equalsTracker);\n              tracker = 0;\n              angular.forEach(sources,function(value,key){\n                if(angular.isArray(value)){\n                  tracker += value.length;\n                }\n              });\n               if(angular.isNumber(equalsTracker)){\n                return tracker + sources.length + equalsTracker;\n               }else{\n                return tracker + sources.length;\n              }\n            };\n            /* update the calendar with the correct options */\n            function update() {\n              //calendar object exposed on scope\n              scope.calendar = elm.html('');\n              var view = scope.calendar.fullCalendar('getView');\n              if(view){\n                view = view.name; //setting the default view to be whatever the current view is. This can be overwritten. \n              }\n              /* If the calendar has options added then render them */\n              var expression,\n                options = {\n                  defaultView : view,\n                  eventSources: sources\n                };\n              if (attrs.uiCalendar) {\n                expression = scope.$eval(attrs.uiCalendar);\n              } else {\n                expression = {};\n              }\n              angular.extend(options, uiConfig.uiCalendar, expression);\n              scope.calendar.fullCalendar(options);\n            }\n            update();\n              /* watches all eventSources */\n              scope.$watch(getSources, function( newVal, oldVal )\n              {\n                update();\n              });\n         }\n    };\n}]);\n/*global angular, CodeMirror, Error*/\n/**\n * Binds a CodeMirror widget to a <textarea> element.\n */\nangular.module('ui.directives').directive('uiCodemirror', ['ui.config', '$timeout', function (uiConfig, $timeout) {\n\t'use strict';\n\n\tvar events = [\"cursorActivity\", \"viewportChange\", \"gutterClick\", \"focus\", \"blur\", \"scroll\", \"update\"];\n\treturn {\n\t\trestrict:'A',\n\t\trequire:'ngModel',\n\t\tlink:function (scope, elm, attrs, ngModel) {\n\t\t\tvar options, opts, onChange, deferCodeMirror, codeMirror;\n\n\t\t\tif (elm[0].type !== 'textarea') {\n\t\t\t\tthrow new Error('uiCodemirror3 can only be applied to a textarea element');\n\t\t\t}\n\n\t\t\toptions = uiConfig.codemirror || {};\n\t\t\topts = angular.extend({}, options, scope.$eval(attrs.uiCodemirror));\n\n\t\t\tonChange = function (aEvent) {\n\t\t\t\treturn function (instance, changeObj) {\n\t\t\t\t\tvar newValue = instance.getValue();\n\t\t\t\t\tif (newValue !== ngModel.$viewValue) {\n\t\t\t\t\t\tngModel.$setViewValue(newValue);\n\t\t\t\t\t\tscope.$apply();\n\t\t\t\t\t}\n\t\t\t\t\tif (typeof aEvent === \"function\")\n\t\t\t\t\t\taEvent(instance, changeObj);\n\t\t\t\t};\n\t\t\t};\n\n\t\t\tdeferCodeMirror = function () {\n\t\t\t\tcodeMirror = CodeMirror.fromTextArea(elm[0], opts);\n\t\t\t\tcodeMirror.on(\"change\", onChange(opts.onChange));\n\n\t\t\t\tfor (var i = 0, n = events.length, aEvent; i < n; ++i) {\n\t\t\t\t\taEvent = opts[\"on\" + events[i].charAt(0).toUpperCase() + events[i].slice(1)];\n\t\t\t\t\tif (aEvent === void 0) continue;\n\t\t\t\t\tif (typeof aEvent !== \"function\") continue;\n\t\t\t\t\tcodeMirror.on(events[i], aEvent);\n\t\t\t\t}\n\n\t\t\t\t// CodeMirror expects a string, so make sure it gets one.\n\t\t\t\t// This does not change the model.\n\t\t\t\tngModel.$formatters.push(function (value) {\n\t\t\t\t\tif (angular.isUndefined(value) || value === null) {\n\t\t\t\t\t\treturn '';\n\t\t\t\t\t}\n\t\t\t\t\telse if (angular.isObject(value) || angular.isArray(value)) {\n\t\t\t\t\t\tthrow new Error('ui-codemirror cannot use an object or an array as a model');\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t});\n\n\t\t\t\t// Override the ngModelController $render method, which is what gets called when the model is updated.\n\t\t\t\t// This takes care of the synchronizing the codeMirror element with the underlying model, in the case that it is changed by something else.\n\t\t\t\tngModel.$render = function () {\n\t\t\t\t\tcodeMirror.setValue(ngModel.$viewValue);\n\t\t\t\t};\n\n\t\t\t\t// Watch ui-refresh and refresh the directive\n\t\t\t\tif (attrs.uiRefresh) {\n\t\t\t\t\tscope.$watch(attrs.uiRefresh, function(newVal, oldVal){\n\t\t\t\t\t\t// Skip the initial watch firing\n\t\t\t\t\t\tif (newVal !== oldVal)\n\t\t\t\t\t\t\t$timeout(codeMirror.refresh);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t$timeout(deferCodeMirror);\n\n\t\t}\n\t};\n}]);\n\n/*\n Gives the ability to style currency based on its sign.\n */\nangular.module('ui.directives').directive('uiCurrency', ['ui.config', 'currencyFilter' , function (uiConfig, currencyFilter) {\n  var options = {\n    pos: 'ui-currency-pos',\n    neg: 'ui-currency-neg',\n    zero: 'ui-currency-zero'\n  };\n  if (uiConfig.currency) {\n    angular.extend(options, uiConfig.currency);\n  }\n  return {\n    restrict: 'EAC',\n    require: 'ngModel',\n    link: function (scope, element, attrs, controller) {\n      var opts, // instance-specific options\n        renderview,\n        value;\n\n      opts = angular.extend({}, options, scope.$eval(attrs.uiCurrency));\n\n      renderview = function (viewvalue) {\n        var num;\n        num = viewvalue * 1;\n        element.toggleClass(opts.pos, (num > 0) );\n        element.toggleClass(opts.neg, (num < 0) );\n        element.toggleClass(opts.zero, (num === 0) );\n        if (viewvalue === '') {\n          element.text('');\n        } else {\n          element.text(currencyFilter(num, opts.symbol));\n        }\n        return true;\n      };\n\n      controller.$render = function () {\n        value = controller.$viewValue;\n        element.val(value);\n        renderview(value);\n      };\n\n    }\n  };\n}]);\n\n/*global angular */\n/*\n jQuery UI Datepicker plugin wrapper\n\n @note If â‰¤ IE8 make sure you have a polyfill for Date.toISOString()\n @param [ui-date] {object} Options to pass to $.fn.datepicker() merged onto ui.config\n */\n\nangular.module('ui.directives')\n\n.directive('uiDate', ['ui.config', function (uiConfig) {\n  'use strict';\n  var options;\n  options = {};\n  if (angular.isObject(uiConfig.date)) {\n    angular.extend(options, uiConfig.date);\n  }\n  return {\n    require:'?ngModel',\n    link:function (scope, element, attrs, controller) {\n      var getOptions = function () {\n        return angular.extend({}, uiConfig.date, scope.$eval(attrs.uiDate));\n      };\n      var initDateWidget = function () {\n        var opts = getOptions();\n\n        // If we have a controller (i.e. ngModelController) then wire it up\n        if (controller) {\n          var updateModel = function () {\n            scope.$apply(function () {\n              var date = element.datepicker(\"getDate\");\n              element.datepicker(\"setDate\", element.val());\n              controller.$setViewValue(date);\n              element.blur();\n            });\n          };\n          if (opts.onSelect) {\n            // Caller has specified onSelect, so call this as well as updating the model\n            var userHandler = opts.onSelect;\n            opts.onSelect = function (value, picker) {\n              updateModel();\n              scope.$apply(function() {\n                userHandler(value, picker);\n              });\n            };\n          } else {\n            // No onSelect already specified so just update the model\n            opts.onSelect = updateModel;\n          }\n          // In case the user changes the text directly in the input box\n          element.bind('change', updateModel);\n\n          // Update the date picker when the model changes\n          controller.$render = function () {\n            var date = controller.$viewValue;\n            if ( angular.isDefined(date) && date !== null && !angular.isDate(date) ) {\n              throw new Error('ng-Model value must be a Date object - currently it is a ' + typeof date + ' - use ui-date-format to convert it from a string');\n            }\n            element.datepicker(\"setDate\", date);\n          };\n        }\n        // If we don't destroy the old one it doesn't update properly when the config changes\n        element.datepicker('destroy');\n        // Create the new datepicker widget\n        element.datepicker(opts);\n        if ( controller ) {\n          // Force a render to override whatever is in the input text box\n          controller.$render();\n        }\n      };\n      // Watch for changes to the directives options\n      scope.$watch(getOptions, initDateWidget, true);\n    }\n  };\n}\n])\n\n.directive('uiDateFormat', ['ui.config', function(uiConfig) {\n  var directive = {\n    require:'ngModel',\n    link: function(scope, element, attrs, modelCtrl) {\n      var dateFormat = attrs.uiDateFormat || uiConfig.dateFormat;\n      if ( dateFormat ) {\n        // Use the datepicker with the attribute value as the dateFormat string to convert to and from a string\n        modelCtrl.$formatters.push(function(value) {\n          if (angular.isString(value) ) {\n            return $.datepicker.parseDate(dateFormat, value);\n          }\n        });\n        modelCtrl.$parsers.push(function(value){\n          if (value) {\n            return $.datepicker.formatDate(dateFormat, value);\n          }\n        });\n      } else {\n        // Default to ISO formatting\n        modelCtrl.$formatters.push(function(value) {\n          if (angular.isString(value) ) {\n            return new Date(value);\n          }\n        });\n        modelCtrl.$parsers.push(function(value){\n          if (value) {\n            return value.toISOString();\n          }\n        });\n      }\n    }\n  };\n  return directive;\n}]);\n\n/**\n * General-purpose Event binding. Bind any event not natively supported by Angular\n * Pass an object with keynames for events to ui-event\n * Allows $event object and $params object to be passed\n *\n * @example <input ui-event=\"{ focus : 'counter++', blur : 'someCallback()' }\">\n * @example <input ui-event=\"{ myCustomEvent : 'myEventHandler($event, $params)'}\">\n *\n * @param ui-event {string|object literal} The event to bind to as a string or a hash of events with their callbacks\n */\nangular.module('ui.directives').directive('uiEvent', ['$parse',\n  function ($parse) {\n    return function (scope, elm, attrs) {\n      var events = scope.$eval(attrs.uiEvent);\n      angular.forEach(events, function (uiEvent, eventName) {\n        var fn = $parse(uiEvent);\n        elm.bind(eventName, function (evt) {\n          var params = Array.prototype.slice.call(arguments);\n          //Take out first paramater (event object);\n          params = params.splice(1);\n          scope.$apply(function () {\n            fn(scope, {$event: evt, $params: params});\n          });\n        });\n      });\n    };\n  }]);\n\n/*\n * Defines the ui-if tag. This removes/adds an element from the dom depending on a condition\n * Originally created by @tigbro, for the @jquery-mobile-angular-adapter\n * https://github.com/tigbro/jquery-mobile-angular-adapter\n */\nangular.module('ui.directives').directive('uiIf', [function () {\n  return {\n    transclude: 'element',\n    priority: 1000,\n    terminal: true,\n    restrict: 'A',\n    compile: function (element, attr, transclude) {\n      return function (scope, element, attr) {\n\n        var childElement;\n        var childScope;\n \n        scope.$watch(attr['uiIf'], function (newValue) {\n          if (childElement) {\n            childElement.remove();\n            childElement = undefined;\n          }\n          if (childScope) {\n            childScope.$destroy();\n            childScope = undefined;\n          }\n\n          if (newValue) {\n            childScope = scope.$new();\n            transclude(childScope, function (clone) {\n              childElement = clone;\n              element.after(clone);\n            });\n          }\n        });\n      };\n    }\n  };\n}]);\n/**\n * General-purpose jQuery wrapper. Simply pass the plugin name as the expression.\n *\n * It is possible to specify a default set of parameters for each jQuery plugin.\n * Under the jq key, namespace each plugin by that which will be passed to ui-jq.\n * Unfortunately, at this time you can only pre-define the first parameter.\n * @example { jq : { datepicker : { showOn:'click' } } }\n *\n * @param ui-jq {string} The $elm.[pluginName]() to call.\n * @param [ui-options] {mixed} Expression to be evaluated and passed as options to the function\n *     Multiple parameters can be separated by commas\n * @param [ui-refresh] {expression} Watch expression and refire plugin on changes\n *\n * @example <input ui-jq=\"datepicker\" ui-options=\"{showOn:'click'},secondParameter,thirdParameter\" ui-refresh=\"iChange\">\n */\nangular.module('ui.directives').directive('uiJq', ['ui.config', '$timeout', function uiJqInjectingFunction(uiConfig, $timeout) {\n\n  return {\n    restrict: 'A',\n    compile: function uiJqCompilingFunction(tElm, tAttrs) {\n\n      if (!angular.isFunction(tElm[tAttrs.uiJq])) {\n        throw new Error('ui-jq: The \"' + tAttrs.uiJq + '\" function does not exist');\n      }\n      var options = uiConfig.jq && uiConfig.jq[tAttrs.uiJq];\n\n      return function uiJqLinkingFunction(scope, elm, attrs) {\n\n        var linkOptions = [];\n\n        // If ui-options are passed, merge (or override) them onto global defaults and pass to the jQuery method\n        if (attrs.uiOptions) {\n          linkOptions = scope.$eval('[' + attrs.uiOptions + ']');\n          if (angular.isObject(options) && angular.isObject(linkOptions[0])) {\n            linkOptions[0] = angular.extend({}, options, linkOptions[0]);\n          }\n        } else if (options) {\n          linkOptions = [options];\n        }\n        // If change compatibility is enabled, the form input's \"change\" event will trigger an \"input\" event\n        if (attrs.ngModel && elm.is('select,input,textarea')) {\n          elm.on('change', function() {\n            elm.trigger('input');\n          });\n        }\n\n        // Call jQuery method and pass relevant options\n        function callPlugin() {\n          $timeout(function() {\n            elm[attrs.uiJq].apply(elm, linkOptions);\n          }, 0, false);\n        }\n\n        // If ui-refresh is used, re-fire the the method upon every change\n        if (attrs.uiRefresh) {\n          scope.$watch(attrs.uiRefresh, function(newVal) {\n            callPlugin();\n          });\n        }\n        callPlugin();\n      };\n    }\n  };\n}]);\n\nangular.module('ui.directives').factory('keypressHelper', ['$parse', function keypress($parse){\n  var keysByCode = {\n    8: 'backspace',\n    9: 'tab',\n    13: 'enter',\n    27: 'esc',\n    32: 'space',\n    33: 'pageup',\n    34: 'pagedown',\n    35: 'end',\n    36: 'home',\n    37: 'left',\n    38: 'up',\n    39: 'right',\n    40: 'down',\n    45: 'insert',\n    46: 'delete'\n  };\n\n  var capitaliseFirstLetter = function (string) {\n    return string.charAt(0).toUpperCase() + string.slice(1);\n  };\n\n  return function(mode, scope, elm, attrs) {\n    var params, combinations = [];\n    params = scope.$eval(attrs['ui'+capitaliseFirstLetter(mode)]);\n\n    // Prepare combinations for simple checking\n    angular.forEach(params, function (v, k) {\n      var combination, expression;\n      expression = $parse(v);\n\n      angular.forEach(k.split(' '), function(variation) {\n        combination = {\n          expression: expression,\n          keys: {}\n        };\n        angular.forEach(variation.split('-'), function (value) {\n          combination.keys[value] = true;\n        });\n        combinations.push(combination);\n      });\n    });\n\n    // Check only matching of pressed keys one of the conditions\n    elm.bind(mode, function (event) {\n      // No need to do that inside the cycle\n      var altPressed = event.metaKey || event.altKey;\n      var ctrlPressed = event.ctrlKey;\n      var shiftPressed = event.shiftKey;\n      var keyCode = event.keyCode;\n\n      // normalize keycodes\n      if (mode === 'keypress' && !shiftPressed && keyCode >= 97 && keyCode <= 122) {\n        keyCode = keyCode - 32;\n      }\n\n      // Iterate over prepared combinations\n      angular.forEach(combinations, function (combination) {\n\n        var mainKeyPressed = (combination.keys[keysByCode[event.keyCode]] || combination.keys[event.keyCode.toString()]) || false;\n\n        var altRequired = combination.keys.alt || false;\n        var ctrlRequired = combination.keys.ctrl || false;\n        var shiftRequired = combination.keys.shift || false;\n\n        if (\n          mainKeyPressed &&\n          ( altRequired == altPressed ) &&\n          ( ctrlRequired == ctrlPressed ) &&\n          ( shiftRequired == shiftPressed )\n        ) {\n          // Run the function\n          scope.$apply(function () {\n            combination.expression(scope, { '$event': event });\n          });\n        }\n      });\n    });\n  };\n}]);\n\n/**\n * Bind one or more handlers to particular keys or their combination\n * @param hash {mixed} keyBindings Can be an object or string where keybinding expression of keys or keys combinations and AngularJS Exspressions are set. Object syntax: \"{ keys1: expression1 [, keys2: expression2 [ , ... ]]}\". String syntax: \"\"expression1 on keys1 [ and expression2 on keys2 [ and ... ]]\"\". Expression is an AngularJS Expression, and key(s) are dash-separated combinations of keys and modifiers (one or many, if any. Order does not matter). Supported modifiers are 'ctrl', 'shift', 'alt' and key can be used either via its keyCode (13 for Return) or name. Named keys are 'backspace', 'tab', 'enter', 'esc', 'space', 'pageup', 'pagedown', 'end', 'home', 'left', 'up', 'right', 'down', 'insert', 'delete'.\n * @example <input ui-keypress=\"{enter:'x = 1', 'ctrl-shift-space':'foo()', 'shift-13':'bar()'}\" /> <input ui-keypress=\"foo = 2 on ctrl-13 and bar('hello') on shift-esc\" />\n **/\nangular.module('ui.directives').directive('uiKeydown', ['keypressHelper', function(keypressHelper){\n  return {\n    link: function (scope, elm, attrs) {\n      keypressHelper('keydown', scope, elm, attrs);\n    }\n  };\n}]);\n\nangular.module('ui.directives').directive('uiKeypress', ['keypressHelper', function(keypressHelper){\n  return {\n    link: function (scope, elm, attrs) {\n      keypressHelper('keypress', scope, elm, attrs);\n    }\n  };\n}]);\n\nangular.module('ui.directives').directive('uiKeyup', ['keypressHelper', function(keypressHelper){\n  return {\n    link: function (scope, elm, attrs) {\n      keypressHelper('keyup', scope, elm, attrs);\n    }\n  };\n}]);\n(function () {\n  var app = angular.module('ui.directives');\n\n  //Setup map events from a google map object to trigger on a given element too,\n  //then we just use ui-event to catch events from an element\n  function bindMapEvents(scope, eventsStr, googleObject, element) {\n    angular.forEach(eventsStr.split(' '), function (eventName) {\n      //Prefix all googlemap events with 'map-', so eg 'click' \n      //for the googlemap doesn't interfere with a normal 'click' event\n      var $event = { type: 'map-' + eventName };\n      google.maps.event.addListener(googleObject, eventName, function (evt) {\n        element.triggerHandler(angular.extend({}, $event, evt));\n        //We create an $apply if it isn't happening. we need better support for this\n        //We don't want to use timeout because tons of these events fire at once,\n        //and we only need one $apply\n        if (!scope.$$phase) scope.$apply();\n      });\n    });\n  }\n\n  app.directive('uiMap',\n    ['ui.config', '$parse', function (uiConfig, $parse) {\n\n      var mapEvents = 'bounds_changed center_changed click dblclick drag dragend ' +\n        'dragstart heading_changed idle maptypeid_changed mousemove mouseout ' +\n        'mouseover projection_changed resize rightclick tilesloaded tilt_changed ' +\n        'zoom_changed';\n      var options = uiConfig.map || {};\n\n      return {\n        restrict: 'A',\n        //doesn't work as E for unknown reason\n        link: function (scope, elm, attrs) {\n          var opts = angular.extend({}, options, scope.$eval(attrs.uiOptions));\n          var map = new google.maps.Map(elm[0], opts);\n          var model = $parse(attrs.uiMap);\n\n          //Set scope variable for the map\n          model.assign(scope, map);\n\n          bindMapEvents(scope, mapEvents, map, elm);\n        }\n      };\n    }]);\n\n  app.directive('uiMapInfoWindow',\n    ['ui.config', '$parse', '$compile', function (uiConfig, $parse, $compile) {\n\n      var infoWindowEvents = 'closeclick content_change domready ' +\n        'position_changed zindex_changed';\n      var options = uiConfig.mapInfoWindow || {};\n\n      return {\n        link: function (scope, elm, attrs) {\n          var opts = angular.extend({}, options, scope.$eval(attrs.uiOptions));\n          opts.content = elm[0];\n          var model = $parse(attrs.uiMapInfoWindow);\n          var infoWindow = model(scope);\n\n          if (!infoWindow) {\n            infoWindow = new google.maps.InfoWindow(opts);\n            model.assign(scope, infoWindow);\n          }\n\n          bindMapEvents(scope, infoWindowEvents, infoWindow, elm);\n\n          /* The info window's contents dont' need to be on the dom anymore,\n           google maps has them stored.  So we just replace the infowindow element\n           with an empty div. (we don't just straight remove it from the dom because\n           straight removing things from the dom can mess up angular) */\n          elm.replaceWith('<div></div>');\n\n          //Decorate infoWindow.open to $compile contents before opening\n          var _open = infoWindow.open;\n          infoWindow.open = function open(a1, a2, a3, a4, a5, a6) {\n            $compile(elm.contents())(scope);\n            _open.call(infoWindow, a1, a2, a3, a4, a5, a6);\n          };\n        }\n      };\n    }]);\n\n  /* \n   * Map overlay directives all work the same. Take map marker for example\n   * <ui-map-marker=\"myMarker\"> will $watch 'myMarker' and each time it changes,\n   * it will hook up myMarker's events to the directive dom element.  Then\n   * ui-event will be able to catch all of myMarker's events. Super simple.\n   */\n  function mapOverlayDirective(directiveName, events) {\n    app.directive(directiveName, [function () {\n      return {\n        restrict: 'A',\n        link: function (scope, elm, attrs) {\n          scope.$watch(attrs[directiveName], function (newObject) {\n            bindMapEvents(scope, events, newObject, elm);\n          });\n        }\n      };\n    }]);\n  }\n\n  mapOverlayDirective('uiMapMarker',\n    'animation_changed click clickable_changed cursor_changed ' +\n      'dblclick drag dragend draggable_changed dragstart flat_changed icon_changed ' +\n      'mousedown mouseout mouseover mouseup position_changed rightclick ' +\n      'shadow_changed shape_changed title_changed visible_changed zindex_changed');\n\n  mapOverlayDirective('uiMapPolyline',\n    'click dblclick mousedown mousemove mouseout mouseover mouseup rightclick');\n\n  mapOverlayDirective('uiMapPolygon',\n    'click dblclick mousedown mousemove mouseout mouseover mouseup rightclick');\n\n  mapOverlayDirective('uiMapRectangle',\n    'bounds_changed click dblclick mousedown mousemove mouseout mouseover ' +\n      'mouseup rightclick');\n\n  mapOverlayDirective('uiMapCircle',\n    'center_changed click dblclick mousedown mousemove ' +\n      'mouseout mouseover mouseup radius_changed rightclick');\n\n  mapOverlayDirective('uiMapGroundOverlay',\n    'click dblclick');\n\n})();\n/*\n Attaches jquery-ui input mask onto input element\n */\nangular.module('ui.directives').directive('uiMask', [\n  function () {\n    return {\n      require:'ngModel',\n      link:function ($scope, element, attrs, controller) {\n\n        /* We override the render method to run the jQuery mask plugin\n         */\n        controller.$render = function () {\n          var value = controller.$viewValue || '';\n          element.val(value);\n          element.mask($scope.$eval(attrs.uiMask));\n        };\n\n        /* Add a parser that extracts the masked value into the model but only if the mask is valid\n         */\n        controller.$parsers.push(function (value) {\n          //the second check (or) is only needed due to the fact that element.isMaskValid() will keep returning undefined\n          //until there was at least one key event\n          var isValid = element.isMaskValid() || angular.isUndefined(element.isMaskValid()) && element.val().length>0;\n          controller.$setValidity('mask', isValid);\n          return isValid ? value : undefined;\n        });\n\n        /* When keyup, update the view value\n         */\n        element.bind('keyup', function () {\n          $scope.$apply(function () {\n            controller.$setViewValue(element.mask());\n          });\n        });\n      }\n    };\n  }\n]);\n\n/**\n * Add a clear button to form inputs to reset their value\n */\nangular.module('ui.directives').directive('uiReset', ['ui.config', function (uiConfig) {\n  var resetValue = null;\n  if (uiConfig.reset !== undefined)\n      resetValue = uiConfig.reset;\n  return {\n    require: 'ngModel',\n    link: function (scope, elm, attrs, ctrl) {\n      var aElement;\n      aElement = angular.element('<a class=\"ui-reset\" />');\n      elm.wrap('<span class=\"ui-resetwrap\" />').after(aElement);\n      aElement.bind('click', function (e) {\n        e.preventDefault();\n        scope.$apply(function () {\n          if (attrs.uiReset)\n            ctrl.$setViewValue(scope.$eval(attrs.uiReset));\n          else\n            ctrl.$setViewValue(resetValue);\n          ctrl.$render();\n        });\n      });\n    }\n  };\n}]);\n\n/**\n * Set a $uiRoute boolean to see if the current route matches\n */\nangular.module('ui.directives').directive('uiRoute', ['$location', '$parse', function ($location, $parse) {\n  return {\n    restrict: 'AC',\n    compile: function(tElement, tAttrs) {\n      var useProperty;\n      if (tAttrs.uiRoute) {\n        useProperty = 'uiRoute';\n      } else if (tAttrs.ngHref) {\n        useProperty = 'ngHref';\n      } else if (tAttrs.href) {\n        useProperty = 'href';\n      } else {\n        throw new Error('uiRoute missing a route or href property on ' + tElement[0]);\n      }\n      return function ($scope, elm, attrs) {\n        var modelSetter = $parse(attrs.ngModel || attrs.routeModel || '$uiRoute').assign;\n        var watcher = angular.noop;\n\n        // Used by href and ngHref\n        function staticWatcher(newVal) {\n          if ((hash = newVal.indexOf('#')) > -1)\n            newVal = newVal.substr(hash + 1);\n          watcher = function watchHref() {\n            modelSetter($scope, ($location.path().indexOf(newVal) > -1));\n          };\n          watcher();\n        }\n        // Used by uiRoute\n        function regexWatcher(newVal) {\n          if ((hash = newVal.indexOf('#')) > -1)\n            newVal = newVal.substr(hash + 1);\n          watcher = function watchRegex() {\n            var regexp = new RegExp('^' + newVal + '$', ['i']);\n            modelSetter($scope, regexp.test($location.path()));\n          };\n          watcher();\n        }\n\n        switch (useProperty) {\n          case 'uiRoute':\n            // if uiRoute={{}} this will be undefined, otherwise it will have a value and $observe() never gets triggered\n            if (attrs.uiRoute)\n              regexWatcher(attrs.uiRoute);\n            else\n              attrs.$observe('uiRoute', regexWatcher);\n            break;\n          case 'ngHref':\n            // Setup watcher() every time ngHref changes\n            if (attrs.ngHref)\n              staticWatcher(attrs.ngHref);\n            else\n              attrs.$observe('ngHref', staticWatcher);\n            break;\n          case 'href':\n            // Setup watcher()\n            staticWatcher(attrs.href);\n        }\n\n        $scope.$on('$routeChangeSuccess', function(){\n          watcher();\n        });\n      }\n    }\n  };\n}]);\n\n/*global angular, $, document*/\n/**\n * Adds a 'ui-scrollfix' class to the element when the page scrolls past it's position.\n * @param [offset] {int} optional Y-offset to override the detected offset.\n *   Takes 300 (absolute) or -300 or +300 (relative to detected)\n */\nangular.module('ui.directives').directive('uiScrollfix', ['$window', function ($window) {\n  'use strict';\n  return {\n    link: function (scope, elm, attrs) {\n      var top = elm.offset().top;\n      if (!attrs.uiScrollfix) {\n        attrs.uiScrollfix = top;\n      } else {\n        // chartAt is generally faster than indexOf: http://jsperf.com/indexof-vs-chartat\n        if (attrs.uiScrollfix.charAt(0) === '-') {\n          attrs.uiScrollfix = top - attrs.uiScrollfix.substr(1);\n        } else if (attrs.uiScrollfix.charAt(0) === '+') {\n          attrs.uiScrollfix = top + parseFloat(attrs.uiScrollfix.substr(1));\n        }\n      }\n      angular.element($window).on('scroll.ui-scrollfix', function () {\n        // if pageYOffset is defined use it, otherwise use other crap for IE\n        var offset;\n        if (angular.isDefined($window.pageYOffset)) {\n          offset = $window.pageYOffset;\n        } else {\n          var iebody = (document.compatMode && document.compatMode !== \"BackCompat\") ? document.documentElement : document.body;\n          offset = iebody.scrollTop;\n        }\n        if (!elm.hasClass('ui-scrollfix') && offset > attrs.uiScrollfix) {\n          elm.addClass('ui-scrollfix');\n        } else if (elm.hasClass('ui-scrollfix') && offset < attrs.uiScrollfix) {\n          elm.removeClass('ui-scrollfix');\n        }\n      });\n    }\n  };\n}]);\n\n/**\n * Enhanced Select2 Dropmenus\n *\n * @AJAX Mode - When in this mode, your value will be an object (or array of objects) of the data used by Select2\n *     This change is so that you do not have to do an additional query yourself on top of Select2's own query\n * @params [options] {object} The configuration options passed to $.fn.select2(). Refer to the documentation\n */\nangular.module('ui.directives').directive('uiSelect2', ['ui.config', '$timeout', function (uiConfig, $timeout) {\n  var options = {};\n  if (uiConfig.select2) {\n    angular.extend(options, uiConfig.select2);\n  }\n  return {\n    require: '?ngModel',\n    compile: function (tElm, tAttrs) {\n      var watch,\n        repeatOption,\n        repeatAttr,\n        isSelect = tElm.is('select'),\n        isMultiple = (tAttrs.multiple !== undefined);\n\n      // Enable watching of the options dataset if in use\n      if (tElm.is('select')) {\n        repeatOption = tElm.find('option[ng-repeat], option[data-ng-repeat]');\n\n        if (repeatOption.length) {\n          repeatAttr = repeatOption.attr('ng-repeat') || repeatOption.attr('data-ng-repeat');\n          watch = jQuery.trim(repeatAttr.split('|')[0]).split(' ').pop();\n        }\n      }\n\n      return function (scope, elm, attrs, controller) {\n        // instance-specific options\n        var opts = angular.extend({}, options, scope.$eval(attrs.uiSelect2));\n\n        if (isSelect) {\n          // Use <select multiple> instead\n          delete opts.multiple;\n          delete opts.initSelection;\n        } else if (isMultiple) {\n          opts.multiple = true;\n        }\n\n        if (controller) {\n          // Watch the model for programmatic changes\n          controller.$render = function () {\n            if (isSelect) {\n              elm.select2('val', controller.$modelValue);\n            } else {\n              if (isMultiple) {\n                if (!controller.$modelValue) {\n                  elm.select2('data', []);\n                } else if (angular.isArray(controller.$modelValue)) {\n                  elm.select2('data', controller.$modelValue);\n                } else {\n                  elm.select2('val', controller.$modelValue);\n                }\n              } else {\n                if (angular.isObject(controller.$modelValue)) {\n                  elm.select2('data', controller.$modelValue);\n                } else {\n                  elm.select2('val', controller.$modelValue);\n                }\n              }\n            }\n          };\n\n          // Watch the options dataset for changes\n          if (watch) {\n            scope.$watch(watch, function (newVal, oldVal, scope) {\n              if (!newVal) return;\n              // Delayed so that the options have time to be rendered\n              $timeout(function () {\n                elm.select2('val', controller.$viewValue);\n                // Refresh angular to remove the superfluous option\n                elm.trigger('change');\n              });\n            });\n          }\n\n          if (!isSelect) {\n            // Set the view and model value and update the angular template manually for the ajax/multiple select2.\n            elm.bind(\"change\", function () {\n              scope.$apply(function () {\n                controller.$setViewValue(elm.select2('data'));\n              });\n            });\n\n            if (opts.initSelection) {\n              var initSelection = opts.initSelection;\n              opts.initSelection = function (element, callback) {\n                initSelection(element, function (value) {\n                  controller.$setViewValue(value);\n                  callback(value);\n                });\n              };\n            }\n          }\n        }\n\n        attrs.$observe('disabled', function (value) {\n          elm.select2(value && 'disable' || 'enable');\n        });\n\n        if (attrs.ngMultiple) {\n          scope.$watch(attrs.ngMultiple, function(newVal) {\n            elm.select2(opts);\n          });\n        }\n\n        // Set initial value since Angular doesn't\n        elm.val(scope.$eval(attrs.ngModel));\n\n        // Initialize the plugin late so that the injected DOM does not disrupt the template compiler\n        $timeout(function () {\n          elm.select2(opts);\n          // Not sure if I should just check for !isSelect OR if I should check for 'tags' key\n          if (!opts.initSelection && !isSelect)\n            controller.$setViewValue(elm.select2('data'));\n        });\n      };\n    }\n  };\n}]);\n\n/**\n * uiShow Directive\n *\n * Adds a 'ui-show' class to the element instead of display:block\n * Created to allow tighter control  of CSS without bulkier directives\n *\n * @param expression {boolean} evaluated expression to determine if the class should be added\n */\nangular.module('ui.directives').directive('uiShow', [function () {\n  return function (scope, elm, attrs) {\n    scope.$watch(attrs.uiShow, function (newVal, oldVal) {\n      if (newVal) {\n        elm.addClass('ui-show');\n      } else {\n        elm.removeClass('ui-show');\n      }\n    });\n  };\n}])\n\n/**\n * uiHide Directive\n *\n * Adds a 'ui-hide' class to the element instead of display:block\n * Created to allow tighter control  of CSS without bulkier directives\n *\n * @param expression {boolean} evaluated expression to determine if the class should be added\n */\n  .directive('uiHide', [function () {\n  return function (scope, elm, attrs) {\n    scope.$watch(attrs.uiHide, function (newVal, oldVal) {\n      if (newVal) {\n        elm.addClass('ui-hide');\n      } else {\n        elm.removeClass('ui-hide');\n      }\n    });\n  };\n}])\n\n/**\n * uiToggle Directive\n *\n * Adds a class 'ui-show' if true, and a 'ui-hide' if false to the element instead of display:block/display:none\n * Created to allow tighter control  of CSS without bulkier directives. This also allows you to override the\n * default visibility of the element using either class.\n *\n * @param expression {boolean} evaluated expression to determine if the class should be added\n */\n  .directive('uiToggle', [function () {\n  return function (scope, elm, attrs) {\n    scope.$watch(attrs.uiToggle, function (newVal, oldVal) {\n      if (newVal) {\n        elm.removeClass('ui-hide').addClass('ui-show');\n      } else {\n        elm.removeClass('ui-show').addClass('ui-hide');\n      }\n    });\n  };\n}]);\n\n/*\n jQuery UI Sortable plugin wrapper\n\n @param [ui-sortable] {object} Options to pass to $.fn.sortable() merged onto ui.config\n*/\nangular.module('ui.directives').directive('uiSortable', [\n  'ui.config', function(uiConfig) {\n    return {\n      require: '?ngModel',\n      link: function(scope, element, attrs, ngModel) {\n        var onReceive, onRemove, onStart, onUpdate, opts, _receive, _remove, _start, _update;\n\n        opts = angular.extend({}, uiConfig.sortable, scope.$eval(attrs.uiSortable));\n\n        if (ngModel) {\n\n          ngModel.$render = function() {\n            element.sortable( \"refresh\" );\n          };\n\n          onStart = function(e, ui) {\n            // Save position of dragged item\n            ui.item.sortable = { index: ui.item.index() };\n          };\n\n          onUpdate = function(e, ui) {\n            // For some reason the reference to ngModel in stop() is wrong\n            ui.item.sortable.resort = ngModel;\n          };\n\n          onReceive = function(e, ui) {\n            ui.item.sortable.relocate = true;\n            // added item to array into correct position and set up flag\n            ngModel.$modelValue.splice(ui.item.index(), 0, ui.item.sortable.moved);\n          };\n\n          onRemove = function(e, ui) {\n            // copy data into item\n            if (ngModel.$modelValue.length === 1) {\n              ui.item.sortable.moved = ngModel.$modelValue.splice(0, 1)[0];\n            } else {\n              ui.item.sortable.moved =  ngModel.$modelValue.splice(ui.item.sortable.index, 1)[0];\n            }\n          };\n\n          onStop = function(e, ui) {\n            // digest all prepared changes\n            if (ui.item.sortable.resort && !ui.item.sortable.relocate) {\n\n              // Fetch saved and current position of dropped element\n              var end, start;\n              start = ui.item.sortable.index;\n              end = ui.item.index();\n              if (start < end)\n                end--;\n\n              // Reorder array and apply change to scope\n              ui.item.sortable.resort.$modelValue.splice(end, 0, ui.item.sortable.resort.$modelValue.splice(start, 1)[0]);\n\n            }\n            if (ui.item.sortable.resort || ui.item.sortable.relocate) {\n              scope.$apply();\n            }\n          };\n\n          // If user provided 'start' callback compose it with onStart function\n          _start = opts.start;\n          opts.start = function(e, ui) {\n            onStart(e, ui);\n            if (typeof _start === \"function\")\n              _start(e, ui);\n          };\n\n          // If user provided 'start' callback compose it with onStart function\n          _stop = opts.stop;\n          opts.stop = function(e, ui) {\n            onStop(e, ui);\n            if (typeof _stop === \"function\")\n              _stop(e, ui);\n          };\n\n          // If user provided 'update' callback compose it with onUpdate function\n          _update = opts.update;\n          opts.update = function(e, ui) {\n            onUpdate(e, ui);\n            if (typeof _update === \"function\")\n              _update(e, ui);\n          };\n\n          // If user provided 'receive' callback compose it with onReceive function\n          _receive = opts.receive;\n          opts.receive = function(e, ui) {\n            onReceive(e, ui);\n            if (typeof _receive === \"function\")\n              _receive(e, ui);\n          };\n\n          // If user provided 'remove' callback compose it with onRemove function\n          _remove = opts.remove;\n          opts.remove = function(e, ui) {\n            onRemove(e, ui);\n            if (typeof _remove === \"function\")\n              _remove(e, ui);\n          };\n        }\n\n        // Create sortable\n        element.sortable(opts);\n      }\n    };\n  }\n]);\n\n/**\n * Binds a TinyMCE widget to <textarea> elements.\n */\nangular.module('ui.directives').directive('uiTinymce', ['ui.config', function (uiConfig) {\n  uiConfig.tinymce = uiConfig.tinymce || {};\n  return {\n    require: 'ngModel',\n    link: function (scope, elm, attrs, ngModel) {\n      var expression,\n        options = {\n          // Update model on button click\n          onchange_callback: function (inst) {\n            if (inst.isDirty()) {\n              inst.save();\n              ngModel.$setViewValue(elm.val());\n              if (!scope.$$phase)\n                scope.$apply();\n            }\n          },\n          // Update model on keypress\n          handle_event_callback: function (e) {\n            if (this.isDirty()) {\n              this.save();\n              ngModel.$setViewValue(elm.val());\n              if (!scope.$$phase)\n                scope.$apply();\n            }\n            return true; // Continue handling\n          },\n          // Update model when calling setContent (such as from the source editor popup)\n          setup: function (ed) {\n            ed.onSetContent.add(function (ed, o) {\n              if (ed.isDirty()) {\n                ed.save();\n                ngModel.$setViewValue(elm.val());\n                if (!scope.$$phase)\n                  scope.$apply();\n              }\n            });\n          }\n        };\n      if (attrs.uiTinymce) {\n        expression = scope.$eval(attrs.uiTinymce);\n      } else {\n        expression = {};\n      }\n      angular.extend(options, uiConfig.tinymce, expression);\n      setTimeout(function () {\n        elm.tinymce(options);\n      });\n    }\n  };\n}]);\n\n/**\r\n * General-purpose validator for ngModel.\r\n * angular.js comes with several built-in validation mechanism for input fields (ngRequired, ngPattern etc.) but using\r\n * an arbitrary validation function requires creation of a custom formatters and / or parsers.\r\n * The ui-validate directive makes it easy to use any function(s) defined in scope as a validator function(s).\r\n * A validator function will trigger validation on both model and input changes.\r\n *\r\n * @example <input ui-validate=\" 'myValidatorFunction($value)' \">\r\n * @example <input ui-validate=\"{ foo : '$value > anotherModel', bar : 'validateFoo($value)' }\">\r\n * @example <input ui-validate=\"{ foo : '$value > anotherModel' }\" ui-validate-watch=\" 'anotherModel' \">\r\n * @example <input ui-validate=\"{ foo : '$value > anotherModel', bar : 'validateFoo($value)' }\" ui-validate-watch=\" { foo : 'anotherModel' } \">\r\n *\r\n * @param ui-validate {string|object literal} If strings is passed it should be a scope's function to be used as a validator.\r\n * If an object literal is passed a key denotes a validation error key while a value should be a validator function.\r\n * In both cases validator function should take a value to validate as its argument and should return true/false indicating a validation result.\r\n */\r\nangular.module('ui.directives').directive('uiValidate', function () {\r\n\r\n  return {\r\n    restrict: 'A',\r\n    require: 'ngModel',\r\n    link: function (scope, elm, attrs, ctrl) {\r\n      var validateFn, watch, validators = {},\r\n        validateExpr = scope.$eval(attrs.uiValidate);\r\n\r\n      if (!validateExpr) return;\r\n\r\n      if (angular.isString(validateExpr)) {\r\n        validateExpr = { validator: validateExpr };\r\n      }\r\n\r\n      angular.forEach(validateExpr, function (expression, key) {\r\n        validateFn = function (valueToValidate) {\r\n          if (scope.$eval(expression, { '$value' : valueToValidate })) {\r\n            ctrl.$setValidity(key, true);\r\n            return valueToValidate;\r\n          } else {\r\n            ctrl.$setValidity(key, false);\r\n            return undefined;\r\n          }\r\n        };\r\n        validators[key] = validateFn;\r\n        ctrl.$formatters.push(validateFn);\r\n        ctrl.$parsers.push(validateFn);\r\n      });\r\n\r\n      // Support for ui-validate-watch\r\n      if (attrs.uiValidateWatch) {\r\n        watch = scope.$eval(attrs.uiValidateWatch);\r\n        if (angular.isString(watch)) {\r\n          scope.$watch(watch, function(){\r\n            angular.forEach(validators, function(validatorFn, key){\r\n              validatorFn(ctrl.$modelValue);\r\n            });\r\n          });\r\n        } else {\r\n          angular.forEach(watch, function(expression, key){\r\n            scope.$watch(expression, function(){\r\n              validators[key](ctrl.$modelValue);\r\n            });\r\n          });\r\n        }\r\n      }\r\n    }\r\n  };\r\n});\n\n\n/**\n * A replacement utility for internationalization very similar to sprintf.\n *\n * @param replace {mixed} The tokens to replace depends on type\n *  string: all instances of $0 will be replaced\n *  array: each instance of $0, $1, $2 etc. will be placed with each array item in corresponding order\n *  object: all attributes will be iterated through, with :key being replaced with its corresponding value\n * @return string\n *\n * @example: 'Hello :name, how are you :day'.format({ name:'John', day:'Today' })\n * @example: 'Records $0 to $1 out of $2 total'.format(['10', '20', '3000'])\n * @example: '$0 agrees to all mentions $0 makes in the event that $0 hits a tree while $0 is driving drunk'.format('Bob')\n */\nangular.module('ui.filters').filter('format', function(){\n  return function(value, replace) {\n    if (!value) {\n      return value;\n    }\n    var target = value.toString(), token;\n    if (replace === undefined) {\n      return target;\n    }\n    if (!angular.isArray(replace) && !angular.isObject(replace)) {\n      return target.split('$0').join(replace);\n    }\n    token = angular.isArray(replace) && '$' || ':';\n\n    angular.forEach(replace, function(value, key){\n      target = target.split(token+key).join(value);\n    });\n    return target;\n  };\n});\n\n/**\n * Wraps the\n * @param text {string} haystack to search through\n * @param search {string} needle to search for\n * @param [caseSensitive] {boolean} optional boolean to use case-sensitive searching\n */\nangular.module('ui.filters').filter('highlight', function () {\n  return function (text, search, caseSensitive) {\n    if (search || angular.isNumber(search)) {\n      text = text.toString();\n      search = search.toString();\n      if (caseSensitive) {\n        return text.split(search).join('<span class=\"ui-match\">' + search + '</span>');\n      } else {\n        return text.replace(new RegExp(search, 'gi'), '<span class=\"ui-match\">$&</span>');\n      }\n    } else {\n      return text;\n    }\n  };\n});\n\n/**\n * Converts variable-esque naming conventions to something presentational, capitalized words separated by space.\n * @param {String} value The value to be parsed and prettified.\n * @param {String} [inflector] The inflector to use. Default: humanize.\n * @return {String}\n * @example {{ 'Here Is my_phoneNumber' | inflector:'humanize' }} => Here Is My Phone Number\n *          {{ 'Here Is my_phoneNumber' | inflector:'underscore' }} => here_is_my_phone_number\n *          {{ 'Here Is my_phoneNumber' | inflector:'variable' }} => hereIsMyPhoneNumber\n */\nangular.module('ui.filters').filter('inflector', function () {\n  function ucwords(text) {\n    return text.replace(/^([a-z])|\\s+([a-z])/g, function ($1) {\n      return $1.toUpperCase();\n    });\n  }\n\n  function breakup(text, separator) {\n    return text.replace(/[A-Z]/g, function (match) {\n      return separator + match;\n    });\n  }\n\n  var inflectors = {\n    humanize: function (value) {\n      return ucwords(breakup(value, ' ').split('_').join(' '));\n    },\n    underscore: function (value) {\n      return value.substr(0, 1).toLowerCase() + breakup(value.substr(1), '_').toLowerCase().split(' ').join('_');\n    },\n    variable: function (value) {\n      value = value.substr(0, 1).toLowerCase() + ucwords(value.split('_').join(' ')).substr(1).split(' ').join('');\n      return value;\n    }\n  };\n\n  return function (text, inflector, separator) {\n    if (inflector !== false && angular.isString(text)) {\n      inflector = inflector || 'humanize';\n      return inflectors[inflector](text);\n    } else {\n      return text;\n    }\n  };\n});\n\n/**\n * Filters out all duplicate items from an array by checking the specified key\n * @param [key] {string} the name of the attribute of each object to compare for uniqueness\n if the key is empty, the entire object will be compared\n if the key === false then no filtering will be performed\n * @return {array}\n */\nangular.module('ui.filters').filter('unique', function () {\n\n  return function (items, filterOn) {\n\n    if (filterOn === false) {\n      return items;\n    }\n\n    if ((filterOn || angular.isUndefined(filterOn)) && angular.isArray(items)) {\n      var hashCheck = {}, newItems = [];\n\n      var extractValueToCompare = function (item) {\n        if (angular.isObject(item) && angular.isString(filterOn)) {\n          return item[filterOn];\n        } else {\n          return item;\n        }\n      };\n\n      angular.forEach(items, function (item) {\n        var valueToCheck, isDuplicate = false;\n\n        for (var i = 0; i < newItems.length; i++) {\n          if (angular.equals(extractValueToCompare(newItems[i]), extractValueToCompare(item))) {\n            isDuplicate = true;\n            break;\n          }\n        }\n        if (!isDuplicate) {\n          newItems.push(item);\n        }\n\n      });\n      items = newItems;\n    }\n    return items;\n  };\n});\n"]],"start1":0,"start2":0,"length1":0,"length2":51172}]],"length":51172}
{"contributors":[],"silentsave":false,"ts":1373643062109,"patch":[[{"diffs":[[-1,"/**\n * AngularUI - The companion suite for AngularJS\n * @version v0.4.0 - 2013-02-15\n * @link http://angular-ui.github.com\n * @license MIT License, http://www.opensource.org/licenses/MIT\n */\n\n\nangular.module('ui.config', []).value('ui.config', {});\nangular.module('ui.filters', ['ui.config']);\nangular.module('ui.directives', ['ui.config']);\nangular.module('ui', ['ui.filters', 'ui.directives', 'ui.config']);\n\n/**\n * Animates the injection of new DOM elements by simply creating the DOM with a class and then immediately removing it\n * Animations must be done using CSS3 transitions, but provide excellent flexibility\n *\n * @todo Add proper support for animating out\n * @param [options] {mixed} Can be an object with multiple options, or a string with the animation class\n *    class {string} the CSS class(es) to use. For example, 'ui-hide' might be an excellent alternative class.\n * @example <li ng-repeat=\"item in items\" ui-animate=\" 'ui-hide' \">{{item}}</li>\n */\nangular.module('ui.directives').directive('uiAnimate', ['ui.config', '$timeout', function (uiConfig, $timeout) {\n  var options = {};\n  if (angular.isString(uiConfig.animate)) {\n    options['class'] = uiConfig.animate;\n  } else if (uiConfig.animate) {\n    options = uiConfig.animate;\n  }\n  return {\n    restrict: 'A', // supports using directive as element, attribute and class\n    link: function ($scope, element, attrs) {\n      var opts = {};\n      if (attrs.uiAnimate) {\n        opts = $scope.$eval(attrs.uiAnimate);\n        if (angular.isString(opts)) {\n          opts = {'class': opts};\n        }\n      }\n      opts = angular.extend({'class': 'ui-animate'}, options, opts);\n\n      element.addClass(opts['class']);\n      $timeout(function () {\n        element.removeClass(opts['class']);\n      }, 20, false);\n    }\n  };\n}]);\n\n\n/*\n*  AngularJs Fullcalendar Wrapper for the JQuery FullCalendar\n*  API @ http://arshaw.com/fullcalendar/ \n*  \n*  Angular Calendar Directive that takes in the [eventSources] nested array object as the ng-model and watches (eventSources.length + eventSources[i].length) for changes. \n*       Can also take in multiple event urls as a source object(s) and feed the events per view.\n*       The calendar will watch any eventSource array and update itself when a delta is created  \n*       An equalsTracker attrs has been added for use cases that would render the overall length tracker the same even though the events have changed to force updates.\n*\n*/\n\nangular.module('ui.directives').directive('uiCalendar',['ui.config', '$parse', function (uiConfig,$parse) {\n     uiConfig.uiCalendar = uiConfig.uiCalendar || {};       \n     //returns calendar     \n     return {\n        require: 'ngModel',\n        restrict: 'A',\n          link: function(scope, elm, attrs, $timeout) {\n            var sources = scope.$eval(attrs.ngModel);\n            var tracker = 0;\n            /* returns the length of all source arrays plus the length of eventSource itself */\n            var getSources = function () {\n              var equalsTracker = scope.$eval(attrs.equalsTracker);\n              tracker = 0;\n              angular.forEach(sources,function(value,key){\n                if(angular.isArray(value)){\n                  tracker += value.length;\n                }\n              });\n               if(angular.isNumber(equalsTracker)){\n                return tracker + sources.length + equalsTracker;\n               }else{\n                return tracker + sources.length;\n              }\n            };\n            /* update the calendar with the correct options */\n            function update() {\n              //calendar object exposed on scope\n              scope.calendar = elm.html('');\n              var view = scope.calendar.fullCalendar('getView');\n              if(view){\n                view = view.name; //setting the default view to be whatever the current view is. This can be overwritten. \n              }\n              /* If the calendar has options added then render them */\n              var expression,\n                options = {\n                  defaultView : view,\n                  eventSources: sources\n                };\n              if (attrs.uiCalendar) {\n                expression = scope.$eval(attrs.uiCalendar);\n              } else {\n                expression = {};\n              }\n              angular.extend(options, uiConfig.uiCalendar, expression);\n              scope.calendar.fullCalendar(options);\n            }\n            update();\n              /* watches all eventSources */\n              scope.$watch(getSources, function( newVal, oldVal )\n              {\n                update();\n              });\n         }\n    };\n}]);\n/*global angular, CodeMirror, Error*/\n/**\n * Binds a CodeMirror widget to a <textarea> element.\n */\nangular.module('ui.directives').directive('uiCodemirror', ['ui.config', '$timeout', function (uiConfig, $timeout) {\n\t'use strict';\n\n\tvar events = [\"cursorActivity\", \"viewportChange\", \"gutterClick\", \"focus\", \"blur\", \"scroll\", \"update\"];\n\treturn {\n\t\trestrict:'A',\n\t\trequire:'ngModel',\n\t\tlink:function (scope, elm, attrs, ngModel) {\n\t\t\tvar options, opts, onChange, deferCodeMirror, codeMirror;\n\n\t\t\tif (elm[0].type !== 'textarea') {\n\t\t\t\tthrow new Error('uiCodemirror3 can only be applied to a textarea element');\n\t\t\t}\n\n\t\t\toptions = uiConfig.codemirror || {};\n\t\t\topts = angular.extend({}, options, scope.$eval(attrs.uiCodemirror));\n\n\t\t\tonChange = function (aEvent) {\n\t\t\t\treturn function (instance, changeObj) {\n\t\t\t\t\tvar newValue = instance.getValue();\n\t\t\t\t\tif (newValue !== ngModel.$viewValue) {\n\t\t\t\t\t\tngModel.$setViewValue(newValue);\n\t\t\t\t\t\tscope.$apply();\n\t\t\t\t\t}\n\t\t\t\t\tif (typeof aEvent === \"function\")\n\t\t\t\t\t\taEvent(instance, changeObj);\n\t\t\t\t};\n\t\t\t};\n\n\t\t\tdeferCodeMirror = function () {\n\t\t\t\tcodeMirror = CodeMirror.fromTextArea(elm[0], opts);\n\t\t\t\tcodeMirror.on(\"change\", onChange(opts.onChange));\n\n\t\t\t\tfor (var i = 0, n = events.length, aEvent; i < n; ++i) {\n\t\t\t\t\taEvent = opts[\"on\" + events[i].charAt(0).toUpperCase() + events[i].slice(1)];\n\t\t\t\t\tif (aEvent === void 0) continue;\n\t\t\t\t\tif (typeof aEvent !== \"function\") continue;\n\t\t\t\t\tcodeMirror.on(events[i], aEvent);\n\t\t\t\t}\n\n\t\t\t\t// CodeMirror expects a string, so make sure it gets one.\n\t\t\t\t// This does not change the model.\n\t\t\t\tngModel.$formatters.push(function (value) {\n\t\t\t\t\tif (angular.isUndefined(value) || value === null) {\n\t\t\t\t\t\treturn '';\n\t\t\t\t\t}\n\t\t\t\t\telse if (angular.isObject(value) || angular.isArray(value)) {\n\t\t\t\t\t\tthrow new Error('ui-codemirror cannot use an object or an array as a model');\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t});\n\n\t\t\t\t// Override the ngModelController $render method, which is what gets called when the model is updated.\n\t\t\t\t// This takes care of the synchronizing the codeMirror element with the underlying model, in the case that it is changed by something else.\n\t\t\t\tngModel.$render = function () {\n\t\t\t\t\tcodeMirror.setValue(ngModel.$viewValue);\n\t\t\t\t};\n\n\t\t\t\t// Watch ui-refresh and refresh the directive\n\t\t\t\tif (attrs.uiRefresh) {\n\t\t\t\t\tscope.$watch(attrs.uiRefresh, function(newVal, oldVal){\n\t\t\t\t\t\t// Skip the initial watch firing\n\t\t\t\t\t\tif (newVal !== oldVal)\n\t\t\t\t\t\t\t$timeout(codeMirror.refresh);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t$timeout(deferCodeMirror);\n\n\t\t}\n\t};\n}]);\n\n/*\n Gives the ability to style currency based on its sign.\n */\nangular.module('ui.directives').directive('uiCurrency', ['ui.config', 'currencyFilter' , function (uiConfig, currencyFilter) {\n  var options = {\n    pos: 'ui-currency-pos',\n    neg: 'ui-currency-neg',\n    zero: 'ui-currency-zero'\n  };\n  if (uiConfig.currency) {\n    angular.extend(options, uiConfig.currency);\n  }\n  return {\n    restrict: 'EAC',\n    require: 'ngModel',\n    link: function (scope, element, attrs, controller) {\n      var opts, // instance-specific options\n        renderview,\n        value;\n\n      opts = angular.extend({}, options, scope.$eval(attrs.uiCurrency));\n\n      renderview = function (viewvalue) {\n        var num;\n        num = viewvalue * 1;\n        element.toggleClass(opts.pos, (num > 0) );\n        element.toggleClass(opts.neg, (num < 0) );\n        element.toggleClass(opts.zero, (num === 0) );\n        if (viewvalue === '') {\n          element.text('');\n        } else {\n          element.text(currencyFilter(num, opts.symbol));\n        }\n        return true;\n      };\n\n      controller.$render = function () {\n        value = controller.$viewValue;\n        element.val(value);\n        renderview(value);\n      };\n\n    }\n  };\n}]);\n\n/*global angular */\n/*\n jQuery UI Datepicker plugin wrapper\n\n @note If â‰¤ IE8 make sure you have a polyfill for Date.toISOString()\n @param [ui-date] {object} Options to pass to $.fn.datepicker() merged onto ui.config\n */\n\nangular.module('ui.directives')\n\n.directive('uiDate', ['ui.config', function (uiConfig) {\n  'use strict';\n  var options;\n  options = {};\n  if (angular.isObject(uiConfig.date)) {\n    angular.extend(options, uiConfig.date);\n  }\n  return {\n    require:'?ngModel',\n    link:function (scope, element, attrs, controller) {\n      var getOptions = function () {\n        return angular.extend({}, uiConfig.date, scope.$eval(attrs.uiDate));\n      };\n      var initDateWidget = function () {\n        var opts = getOptions();\n\n        // If we have a controller (i.e. ngModelController) then wire it up\n        if (controller) {\n          var updateModel = function () {\n            scope.$apply(function () {\n              var date = element.datepicker(\"getDate\");\n              element.datepicker(\"setDate\", element.val());\n              controller.$setViewValue(date);\n              element.blur();\n            });\n          };\n          if (opts.onSelect) {\n            // Caller has specified onSelect, so call this as well as updating the model\n            var userHandler = opts.onSelect;\n            opts.onSelect = function (value, picker) {\n              updateModel();\n              scope.$apply(function() {\n                userHandler(value, picker);\n              });\n            };\n          } else {\n            // No onSelect already specified so just update the model\n            opts.onSelect = updateModel;\n          }\n          // In case the user changes the text directly in the input box\n          element.bind('change', updateModel);\n\n          // Update the date picker when the model changes\n          controller.$render = function () {\n            var date = controller.$viewValue;\n            if ( angular.isDefined(date) && date !== null && !angular.isDate(date) ) {\n              throw new Error('ng-Model value must be a Date object - currently it is a ' + typeof date + ' - use ui-date-format to convert it from a string');\n            }\n            element.datepicker(\"setDate\", date);\n          };\n        }\n        // If we don't destroy the old one it doesn't update properly when the config changes\n        element.datepicker('destroy');\n        // Create the new datepicker widget\n        element.datepicker(opts);\n        if ( controller ) {\n          // Force a render to override whatever is in the input text box\n          controller.$render();\n        }\n      };\n      // Watch for changes to the directives options\n      scope.$watch(getOptions, initDateWidget, true);\n    }\n  };\n}\n])\n\n.directive('uiDateFormat', ['ui.config', function(uiConfig) {\n  var directive = {\n    require:'ngModel',\n    link: function(scope, element, attrs, modelCtrl) {\n      var dateFormat = attrs.uiDateFormat || uiConfig.dateFormat;\n      if ( dateFormat ) {\n        // Use the datepicker with the attribute value as the dateFormat string to convert to and from a string\n        modelCtrl.$formatters.push(function(value) {\n          if (angular.isString(value) ) {\n            return $.datepicker.parseDate(dateFormat, value);\n          }\n        });\n        modelCtrl.$parsers.push(function(value){\n          if (value) {\n            return $.datepicker.formatDate(dateFormat, value);\n          }\n        });\n      } else {\n        // Default to ISO formatting\n        modelCtrl.$formatters.push(function(value) {\n          if (angular.isString(value) ) {\n            return new Date(value);\n          }\n        });\n        modelCtrl.$parsers.push(function(value){\n          if (value) {\n            return value.toISOString();\n          }\n        });\n      }\n    }\n  };\n  return directive;\n}]);\n\n/**\n * General-purpose Event binding. Bind any event not natively supported by Angular\n * Pass an object with keynames for events to ui-event\n * Allows $event object and $params object to be passed\n *\n * @example <input ui-event=\"{ focus : 'counter++', blur : 'someCallback()' }\">\n * @example <input ui-event=\"{ myCustomEvent : 'myEventHandler($event, $params)'}\">\n *\n * @param ui-event {string|object literal} The event to bind to as a string or a hash of events with their callbacks\n */\nangular.module('ui.directives').directive('uiEvent', ['$parse',\n  function ($parse) {\n    return function (scope, elm, attrs) {\n      var events = scope.$eval(attrs.uiEvent);\n      angular.forEach(events, function (uiEvent, eventName) {\n        var fn = $parse(uiEvent);\n        elm.bind(eventName, function (evt) {\n          var params = Array.prototype.slice.call(arguments);\n          //Take out first paramater (event object);\n          params = params.splice(1);\n          scope.$apply(function () {\n            fn(scope, {$event: evt, $params: params});\n          });\n        });\n      });\n    };\n  }]);\n\n/*\n * Defines the ui-if tag. This removes/adds an element from the dom depending on a condition\n * Originally created by @tigbro, for the @jquery-mobile-angular-adapter\n * https://github.com/tigbro/jquery-mobile-angular-adapter\n */\nangular.module('ui.directives').directive('uiIf', [function () {\n  return {\n    transclude: 'element',\n    priority: 1000,\n    terminal: true,\n    restrict: 'A',\n    compile: function (element, attr, transclude) {\n      return function (scope, element, attr) {\n\n        var childElement;\n        var childScope;\n \n        scope.$watch(attr['uiIf'], function (newValue) {\n          if (childElement) {\n            childElement.remove();\n            childElement = undefined;\n          }\n          if (childScope) {\n            childScope.$destroy();\n            childScope = undefined;\n          }\n\n          if (newValue) {\n            childScope = scope.$new();\n            transclude(childScope, function (clone) {\n              childElement = clone;\n              element.after(clone);\n            });\n          }\n        });\n      };\n    }\n  };\n}]);\n/**\n * General-purpose jQuery wrapper. Simply pass the plugin name as the expression.\n *\n * It is possible to specify a default set of parameters for each jQuery plugin.\n * Under the jq key, namespace each plugin by that which will be passed to ui-jq.\n * Unfortunately, at this time you can only pre-define the first parameter.\n * @example { jq : { datepicker : { showOn:'click' } } }\n *\n * @param ui-jq {string} The $elm.[pluginName]() to call.\n * @param [ui-options] {mixed} Expression to be evaluated and passed as options to the function\n *     Multiple parameters can be separated by commas\n * @param [ui-refresh] {expression} Watch expression and refire plugin on changes\n *\n * @example <input ui-jq=\"datepicker\" ui-options=\"{showOn:'click'},secondParameter,thirdParameter\" ui-refresh=\"iChange\">\n */\nangular.module('ui.directives').directive('uiJq', ['ui.config', '$timeout', function uiJqInjectingFunction(uiConfig, $timeout) {\n\n  return {\n    restrict: 'A',\n    compile: function uiJqCompilingFunction(tElm, tAttrs) {\n\n      if (!angular.isFunction(tElm[tAttrs.uiJq])) {\n        throw new Error('ui-jq: The \"' + tAttrs.uiJq + '\" function does not exist');\n      }\n      var options = uiConfig.jq && uiConfig.jq[tAttrs.uiJq];\n\n      return function uiJqLinkingFunction(scope, elm, attrs) {\n\n        var linkOptions = [];\n\n        // If ui-options are passed, merge (or override) them onto global defaults and pass to the jQuery method\n        if (attrs.uiOptions) {\n          linkOptions = scope.$eval('[' + attrs.uiOptions + ']');\n          if (angular.isObject(options) && angular.isObject(linkOptions[0])) {\n            linkOptions[0] = angular.extend({}, options, linkOptions[0]);\n          }\n        } else if (options) {\n          linkOptions = [options];\n        }\n        // If change compatibility is enabled, the form input's \"change\" event will trigger an \"input\" event\n        if (attrs.ngModel && elm.is('select,input,textarea')) {\n          elm.on('change', function() {\n            elm.trigger('input');\n          });\n        }\n\n        // Call jQuery method and pass relevant options\n        function callPlugin() {\n          $timeout(function() {\n            elm[attrs.uiJq].apply(elm, linkOptions);\n          }, 0, false);\n        }\n\n        // If ui-refresh is used, re-fire the the method upon every change\n        if (attrs.uiRefresh) {\n          scope.$watch(attrs.uiRefresh, function(newVal) {\n            callPlugin();\n          });\n        }\n        callPlugin();\n      };\n    }\n  };\n}]);\n\nangular.module('ui.directives').factory('keypressHelper', ['$parse', function keypress($parse){\n  var keysByCode = {\n    8: 'backspace',\n    9: 'tab',\n    13: 'enter',\n    27: 'esc',\n    32: 'space',\n    33: 'pageup',\n    34: 'pagedown',\n    35: 'end',\n    36: 'home',\n    37: 'left',\n    38: 'up',\n    39: 'right',\n    40: 'down',\n    45: 'insert',\n    46: 'delete'\n  };\n\n  var capitaliseFirstLetter = function (string) {\n    return string.charAt(0).toUpperCase() + string.slice(1);\n  };\n\n  return function(mode, scope, elm, attrs) {\n    var params, combinations = [];\n    params = scope.$eval(attrs['ui'+capitaliseFirstLetter(mode)]);\n\n    // Prepare combinations for simple checking\n    angular.forEach(params, function (v, k) {\n      var combination, expression;\n      expression = $parse(v);\n\n      angular.forEach(k.split(' '), function(variation) {\n        combination = {\n          expression: expression,\n          keys: {}\n        };\n        angular.forEach(variation.split('-'), function (value) {\n          combination.keys[value] = true;\n        });\n        combinations.push(combination);\n      });\n    });\n\n    // Check only matching of pressed keys one of the conditions\n    elm.bind(mode, function (event) {\n      // No need to do that inside the cycle\n      var altPressed = event.metaKey || event.altKey;\n      var ctrlPressed = event.ctrlKey;\n      var shiftPressed = event.shiftKey;\n      var keyCode = event.keyCode;\n\n      // normalize keycodes\n      if (mode === 'keypress' && !shiftPressed && keyCode >= 97 && keyCode <= 122) {\n        keyCode = keyCode - 32;\n      }\n\n      // Iterate over prepared combinations\n      angular.forEach(combinations, function (combination) {\n\n        var mainKeyPressed = (combination.keys[keysByCode[event.keyCode]] || combination.keys[event.keyCode.toString()]) || false;\n\n        var altRequired = combination.keys.alt || false;\n        var ctrlRequired = combination.keys.ctrl || false;\n        var shiftRequired = combination.keys.shift || false;\n\n        if (\n          mainKeyPressed &&\n          ( altRequired == altPressed ) &&\n          ( ctrlRequired == ctrlPressed ) &&\n          ( shiftRequired == shiftPressed )\n        ) {\n          // Run the function\n          scope.$apply(function () {\n            combination.expression(scope, { '$event': event });\n          });\n        }\n      });\n    });\n  };\n}]);\n\n/**\n * Bind one or more handlers to particular keys or their combination\n * @param hash {mixed} keyBindings Can be an object or string where keybinding expression of keys or keys combinations and AngularJS Exspressions are set. Object syntax: \"{ keys1: expression1 [, keys2: expression2 [ , ... ]]}\". String syntax: \"\"expression1 on keys1 [ and expression2 on keys2 [ and ... ]]\"\". Expression is an AngularJS Expression, and key(s) are dash-separated combinations of keys and modifiers (one or many, if any. Order does not matter). Supported modifiers are 'ctrl', 'shift', 'alt' and key can be used either via its keyCode (13 for Return) or name. Named keys are 'backspace', 'tab', 'enter', 'esc', 'space', 'pageup', 'pagedown', 'end', 'home', 'left', 'up', 'right', 'down', 'insert', 'delete'.\n * @example <input ui-keypress=\"{enter:'x = 1', 'ctrl-shift-space':'foo()', 'shift-13':'bar()'}\" /> <input ui-keypress=\"foo = 2 on ctrl-13 and bar('hello') on shift-esc\" />\n **/\nangular.module('ui.directives').directive('uiKeydown', ['keypressHelper', function(keypressHelper){\n  return {\n    link: function (scope, elm, attrs) {\n      keypressHelper('keydown', scope, elm, attrs);\n    }\n  };\n}]);\n\nangular.module('ui.directives').directive('uiKeypress', ['keypressHelper', function(keypressHelper){\n  return {\n    link: function (scope, elm, attrs) {\n      keypressHelper('keypress', scope, elm, attrs);\n    }\n  };\n}]);\n\nangular.module('ui.directives').directive('uiKeyup', ['keypressHelper', function(keypressHelper){\n  return {\n    link: function (scope, elm, attrs) {\n      keypressHelper('keyup', scope, elm, attrs);\n    }\n  };\n}]);\n(function () {\n  var app = angular.module('ui.directives');\n\n  //Setup map events from a google map object to trigger on a given element too,\n  //then we just use ui-event to catch events from an element\n  function bindMapEvents(scope, eventsStr, googleObject, element) {\n    angular.forEach(eventsStr.split(' '), function (eventName) {\n      //Prefix all googlemap events with 'map-', so eg 'click' \n      //for the googlemap doesn't interfere with a normal 'click' event\n      var $event = { type: 'map-' + eventName };\n      google.maps.event.addListener(googleObject, eventName, function (evt) {\n        element.triggerHandler(angular.extend({}, $event, evt));\n        //We create an $apply if it isn't happening. we need better support for this\n        //We don't want to use timeout because tons of these events fire at once,\n        //and we only need one $apply\n        if (!scope.$$phase) scope.$apply();\n      });\n    });\n  }\n\n  app.directive('uiMap',\n    ['ui.config', '$parse', function (uiConfig, $parse) {\n\n      var mapEvents = 'bounds_changed center_changed click dblclick drag dragend ' +\n        'dragstart heading_changed idle maptypeid_changed mousemove mouseout ' +\n        'mouseover projection_changed resize rightclick tilesloaded tilt_changed ' +\n        'zoom_changed';\n      var options = uiConfig.map || {};\n\n      return {\n        restrict: 'A',\n        //doesn't work as E for unknown reason\n        link: function (scope, elm, attrs) {\n          var opts = angular.extend({}, options, scope.$eval(attrs.uiOptions));\n          var map = new google.maps.Map(elm[0], opts);\n          var model = $parse(attrs.uiMap);\n\n          //Set scope variable for the map\n          model.assign(scope, map);\n\n          bindMapEvents(scope, mapEvents, map, elm);\n        }\n      };\n    }]);\n\n  app.directive('uiMapInfoWindow',\n    ['ui.config', '$parse', '$compile', function (uiConfig, $parse, $compile) {\n\n      var infoWindowEvents = 'closeclick content_change domready ' +\n        'position_changed zindex_changed';\n      var options = uiConfig.mapInfoWindow || {};\n\n      return {\n        link: function (scope, elm, attrs) {\n          var opts = angular.extend({}, options, scope.$eval(attrs.uiOptions));\n          opts.content = elm[0];\n          var model = $parse(attrs.uiMapInfoWindow);\n          var infoWindow = model(scope);\n\n          if (!infoWindow) {\n            infoWindow = new google.maps.InfoWindow(opts);\n            model.assign(scope, infoWindow);\n          }\n\n          bindMapEvents(scope, infoWindowEvents, infoWindow, elm);\n\n          /* The info window's contents dont' need to be on the dom anymore,\n           google maps has them stored.  So we just replace the infowindow element\n           with an empty div. (we don't just straight remove it from the dom because\n           straight removing things from the dom can mess up angular) */\n          elm.replaceWith('<div></div>');\n\n          //Decorate infoWindow.open to $compile contents before opening\n          var _open = infoWindow.open;\n          infoWindow.open = function open(a1, a2, a3, a4, a5, a6) {\n            $compile(elm.contents())(scope);\n            _open.call(infoWindow, a1, a2, a3, a4, a5, a6);\n          };\n        }\n      };\n    }]);\n\n  /* \n   * Map overlay directives all work the same. Take map marker for example\n   * <ui-map-marker=\"myMarker\"> will $watch 'myMarker' and each time it changes,\n   * it will hook up myMarker's events to the directive dom element.  Then\n   * ui-event will be able to catch all of myMarker's events. Super simple.\n   */\n  function mapOverlayDirective(directiveName, events) {\n    app.directive(directiveName, [function () {\n      return {\n        restrict: 'A',\n        link: function (scope, elm, attrs) {\n          scope.$watch(attrs[directiveName], function (newObject) {\n            bindMapEvents(scope, events, newObject, elm);\n          });\n        }\n      };\n    }]);\n  }\n\n  mapOverlayDirective('uiMapMarker',\n    'animation_changed click clickable_changed cursor_changed ' +\n      'dblclick drag dragend draggable_changed dragstart flat_changed icon_changed ' +\n      'mousedown mouseout mouseover mouseup position_changed rightclick ' +\n      'shadow_changed shape_changed title_changed visible_changed zindex_changed');\n\n  mapOverlayDirective('uiMapPolyline',\n    'click dblclick mousedown mousemove mouseout mouseover mouseup rightclick');\n\n  mapOverlayDirective('uiMapPolygon',\n    'click dblclick mousedown mousemove mouseout mouseover mouseup rightclick');\n\n  mapOverlayDirective('uiMapRectangle',\n    'bounds_changed click dblclick mousedown mousemove mouseout mouseover ' +\n      'mouseup rightclick');\n\n  mapOverlayDirective('uiMapCircle',\n    'center_changed click dblclick mousedown mousemove ' +\n      'mouseout mouseover mouseup radius_changed rightclick');\n\n  mapOverlayDirective('uiMapGroundOverlay',\n    'click dblclick');\n\n})();\n/*\n Attaches jquery-ui input mask onto input element\n */\nangular.module('ui.directives').directive('uiMask', [\n  function () {\n    return {\n      require:'ngModel',\n      link:function ($scope, element, attrs, controller) {\n\n        /* We override the render method to run the jQuery mask plugin\n         */\n        controller.$render = function () {\n          var value = controller.$viewValue || '';\n          element.val(value);\n          element.mask($scope.$eval(attrs.uiMask));\n        };\n\n        /* Add a parser that extracts the masked value into the model but only if the mask is valid\n         */\n        controller.$parsers.push(function (value) {\n          //the second check (or) is only needed due to the fact that element.isMaskValid() will keep returning undefined\n          //until there was at least one key event\n          var isValid = element.isMaskValid() || angular.isUndefined(element.isMaskValid()) && element.val().length>0;\n          controller.$setValidity('mask', isValid);\n          return isValid ? value : undefined;\n        });\n\n        /* When keyup, update the view value\n         */\n        element.bind('keyup', function () {\n          $scope.$apply(function () {\n            controller.$setViewValue(element.mask());\n          });\n        });\n      }\n    };\n  }\n]);\n\n/**\n * Add a clear button to form inputs to reset their value\n */\nangular.module('ui.directives').directive('uiReset', ['ui.config', function (uiConfig) {\n  var resetValue = null;\n  if (uiConfig.reset !== undefined)\n      resetValue = uiConfig.reset;\n  return {\n    require: 'ngModel',\n    link: function (scope, elm, attrs, ctrl) {\n      var aElement;\n      aElement = angular.element('<a class=\"ui-reset\" />');\n      elm.wrap('<span class=\"ui-resetwrap\" />').after(aElement);\n      aElement.bind('click', function (e) {\n        e.preventDefault();\n        scope.$apply(function () {\n          if (attrs.uiReset)\n            ctrl.$setViewValue(scope.$eval(attrs.uiReset));\n          else\n            ctrl.$setViewValue(resetValue);\n          ctrl.$render();\n        });\n      });\n    }\n  };\n}]);\n\n/**\n * Set a $uiRoute boolean to see if the current route matches\n */\nangular.module('ui.directives').directive('uiRoute', ['$location', '$parse', function ($location, $parse) {\n  return {\n    restrict: 'AC',\n    compile: function(tElement, tAttrs) {\n      var useProperty;\n      if (tAttrs.uiRoute) {\n        useProperty = 'uiRoute';\n      } else if (tAttrs.ngHref) {\n        useProperty = 'ngHref';\n      } else if (tAttrs.href) {\n        useProperty = 'href';\n      } else {\n        throw new Error('uiRoute missing a route or href property on ' + tElement[0]);\n      }\n      return function ($scope, elm, attrs) {\n        var modelSetter = $parse(attrs.ngModel || attrs.routeModel || '$uiRoute').assign;\n        var watcher = angular.noop;\n\n        // Used by href and ngHref\n        function staticWatcher(newVal) {\n          if ((hash = newVal.indexOf('#')) > -1)\n            newVal = newVal.substr(hash + 1);\n          watcher = function watchHref() {\n            modelSetter($scope, ($location.path().indexOf(newVal) > -1));\n          };\n          watcher();\n        }\n        // Used by uiRoute\n        function regexWatcher(newVal) {\n          if ((hash = newVal.indexOf('#')) > -1)\n            newVal = newVal.substr(hash + 1);\n          watcher = function watchRegex() {\n            var regexp = new RegExp('^' + newVal + '$', ['i']);\n            modelSetter($scope, regexp.test($location.path()));\n          };\n          watcher();\n        }\n\n        switch (useProperty) {\n          case 'uiRoute':\n            // if uiRoute={{}} this will be undefined, otherwise it will have a value and $observe() never gets triggered\n            if (attrs.uiRoute)\n              regexWatcher(attrs.uiRoute);\n            else\n              attrs.$observe('uiRoute', regexWatcher);\n            break;\n          case 'ngHref':\n            // Setup watcher() every time ngHref changes\n            if (attrs.ngHref)\n              staticWatcher(attrs.ngHref);\n            else\n              attrs.$observe('ngHref', staticWatcher);\n            break;\n          case 'href':\n            // Setup watcher()\n            staticWatcher(attrs.href);\n        }\n\n        $scope.$on('$routeChangeSuccess', function(){\n          watcher();\n        });\n      }\n    }\n  };\n}]);\n\n/*global angular, $, document*/\n/**\n * Adds a 'ui-scrollfix' class to the element when the page scrolls past it's position.\n * @param [offset] {int} optional Y-offset to override the detected offset.\n *   Takes 300 (absolute) or -300 or +300 (relative to detected)\n */\nangular.module('ui.directives').directive('uiScrollfix', ['$window', function ($window) {\n  'use strict';\n  return {\n    link: function (scope, elm, attrs) {\n      var top = elm.offset().top;\n      if (!attrs.uiScrollfix) {\n        attrs.uiScrollfix = top;\n      } else {\n        // chartAt is generally faster than indexOf: http://jsperf.com/indexof-vs-chartat\n        if (attrs.uiScrollfix.charAt(0) === '-') {\n          attrs.uiScrollfix = top - attrs.uiScrollfix.substr(1);\n        } else if (attrs.uiScrollfix.charAt(0) === '+') {\n          attrs.uiScrollfix = top + parseFloat(attrs.uiScrollfix.substr(1));\n        }\n      }\n      angular.element($window).on('scroll.ui-scrollfix', function () {\n        // if pageYOffset is defined use it, otherwise use other crap for IE\n        var offset;\n        if (angular.isDefined($window.pageYOffset)) {\n          offset = $window.pageYOffset;\n        } else {\n          var iebody = (document.compatMode && document.compatMode !== \"BackCompat\") ? document.documentElement : document.body;\n          offset = iebody.scrollTop;\n        }\n        if (!elm.hasClass('ui-scrollfix') && offset > attrs.uiScrollfix) {\n          elm.addClass('ui-scrollfix');\n        } else if (elm.hasClass('ui-scrollfix') && offset < attrs.uiScrollfix) {\n          elm.removeClass('ui-scrollfix');\n        }\n      });\n    }\n  };\n}]);\n\n/**\n * Enhanced Select2 Dropmenus\n *\n * @AJAX Mode - When in this mode, your value will be an object (or array of objects) of the data used by Select2\n *     This change is so that you do not have to do an additional query yourself on top of Select2's own query\n * @params [options] {object} The configuration options passed to $.fn.select2(). Refer to the documentation\n */\nangular.module('ui.directives').directive('uiSelect2', ['ui.config', '$timeout', function (uiConfig, $timeout) {\n  var options = {};\n  if (uiConfig.select2) {\n    angular.extend(options, uiConfig.select2);\n  }\n  return {\n    require: '?ngModel',\n    compile: function (tElm, tAttrs) {\n      var watch,\n        repeatOption,\n        repeatAttr,\n        isSelect = tElm.is('select'),\n        isMultiple = (tAttrs.multiple !== undefined);\n\n      // Enable watching of the options dataset if in use\n      if (tElm.is('select')) {\n        repeatOption = tElm.find('option[ng-repeat], option[data-ng-repeat]');\n\n        if (repeatOption.length) {\n          repeatAttr = repeatOption.attr('ng-repeat') || repeatOption.attr('data-ng-repeat');\n          watch = jQuery.trim(repeatAttr.split('|')[0]).split(' ').pop();\n        }\n      }\n\n      return function (scope, elm, attrs, controller) {\n        // instance-specific options\n        var opts = angular.extend({}, options, scope.$eval(attrs.uiSelect2));\n\n        if (isSelect) {\n          // Use <select multiple> instead\n          delete opts.multiple;\n          delete opts.initSelection;\n        } else if (isMultiple) {\n          opts.multiple = true;\n        }\n\n        if (controller) {\n          // Watch the model for programmatic changes\n          controller.$render = function () {\n            if (isSelect) {\n              elm.select2('val', controller.$modelValue);\n            } else {\n              if (isMultiple) {\n                if (!controller.$modelValue) {\n                  elm.select2('data', []);\n                } else if (angular.isArray(controller.$modelValue)) {\n                  elm.select2('data', controller.$modelValue);\n                } else {\n                  elm.select2('val', controller.$modelValue);\n                }\n              } else {\n                if (angular.isObject(controller.$modelValue)) {\n                  elm.select2('data', controller.$modelValue);\n                } else {\n                  elm.select2('val', controller.$modelValue);\n                }\n              }\n            }\n          };\n\n          // Watch the options dataset for changes\n          if (watch) {\n            scope.$watch(watch, function (newVal, oldVal, scope) {\n              if (!newVal) return;\n              // Delayed so that the options have time to be rendered\n              $timeout(function () {\n                elm.select2('val', controller.$viewValue);\n                // Refresh angular to remove the superfluous option\n                elm.trigger('change');\n              });\n            });\n          }\n\n          if (!isSelect) {\n            // Set the view and model value and update the angular template manually for the ajax/multiple select2.\n            elm.bind(\"change\", function () {\n              scope.$apply(function () {\n                controller.$setViewValue(elm.select2('data'));\n              });\n            });\n\n            if (opts.initSelection) {\n              var initSelection = opts.initSelection;\n              opts.initSelection = function (element, callback) {\n                initSelection(element, function (value) {\n                  controller.$setViewValue(value);\n                  callback(value);\n                });\n              };\n            }\n          }\n        }\n\n        attrs.$observe('disabled', function (value) {\n          elm.select2(value && 'disable' || 'enable');\n        });\n\n        if (attrs.ngMultiple) {\n          scope.$watch(attrs.ngMultiple, function(newVal) {\n            elm.select2(opts);\n          });\n        }\n\n        // Set initial value since Angular doesn't\n        elm.val(scope.$eval(attrs.ngModel));\n\n        // Initialize the plugin late so that the injected DOM does not disrupt the template compiler\n        $timeout(function () {\n          elm.select2(opts);\n          // Not sure if I should just check for !isSelect OR if I should check for 'tags' key\n          if (!opts.initSelection && !isSelect)\n            controller.$setViewValue(elm.select2('data'));\n        });\n      };\n    }\n  };\n}]);\n\n/**\n * uiShow Directive\n *\n * Adds a 'ui-show' class to the element instead of display:block\n * Created to allow tighter control  of CSS without bulkier directives\n *\n * @param expression {boolean} evaluated expression to determine if the class should be added\n */\nangular.module('ui.directives').directive('uiShow', [function () {\n  return function (scope, elm, attrs) {\n    scope.$watch(attrs.uiShow, function (newVal, oldVal) {\n      if (newVal) {\n        elm.addClass('ui-show');\n      } else {\n        elm.removeClass('ui-show');\n      }\n    });\n  };\n}])\n\n/**\n * uiHide Directive\n *\n * Adds a 'ui-hide' class to the element instead of display:block\n * Created to allow tighter control  of CSS without bulkier directives\n *\n * @param expression {boolean} evaluated expression to determine if the class should be added\n */\n  .directive('uiHide', [function () {\n  return function (scope, elm, attrs) {\n    scope.$watch(attrs.uiHide, function (newVal, oldVal) {\n      if (newVal) {\n        elm.addClass('ui-hide');\n      } else {\n        elm.removeClass('ui-hide');\n      }\n    });\n  };\n}])\n\n/**\n * uiToggle Directive\n *\n * Adds a class 'ui-show' if true, and a 'ui-hide' if false to the element instead of display:block/display:none\n * Created to allow tighter control  of CSS without bulkier directives. This also allows you to override the\n * default visibility of the element using either class.\n *\n * @param expression {boolean} evaluated expression to determine if the class should be added\n */\n  .directive('uiToggle', [function () {\n  return function (scope, elm, attrs) {\n    scope.$watch(attrs.uiToggle, function (newVal, oldVal) {\n      if (newVal) {\n        elm.removeClass('ui-hide').addClass('ui-show');\n      } else {\n        elm.removeClass('ui-show').addClass('ui-hide');\n      }\n    });\n  };\n}]);\n\n/*\n jQuery UI Sortable plugin wrapper\n\n @param [ui-sortable] {object} Options to pass to $.fn.sortable() merged onto ui.config\n*/\nangular.module('ui.directives').directive('uiSortable', [\n  'ui.config', function(uiConfig) {\n    return {\n      require: '?ngModel',\n      link: function(scope, element, attrs, ngModel) {\n        var onReceive, onRemove, onStart, onUpdate, opts, _receive, _remove, _start, _update;\n\n        opts = angular.extend({}, uiConfig.sortable, scope.$eval(attrs.uiSortable));\n\n        if (ngModel) {\n\n          ngModel.$render = function() {\n            element.sortable( \"refresh\" );\n          };\n\n          onStart = function(e, ui) {\n            // Save position of dragged item\n            ui.item.sortable = { index: ui.item.index() };\n          };\n\n          onUpdate = function(e, ui) {\n            // For some reason the reference to ngModel in stop() is wrong\n            ui.item.sortable.resort = ngModel;\n          };\n\n          onReceive = function(e, ui) {\n            ui.item.sortable.relocate = true;\n            // added item to array into correct position and set up flag\n            ngModel.$modelValue.splice(ui.item.index(), 0, ui.item.sortable.moved);\n          };\n\n          onRemove = function(e, ui) {\n            // copy data into item\n            if (ngModel.$modelValue.length === 1) {\n              ui.item.sortable.moved = ngModel.$modelValue.splice(0, 1)[0];\n            } else {\n              ui.item.sortable.moved =  ngModel.$modelValue.splice(ui.item.sortable.index, 1)[0];\n            }\n          };\n\n          onStop = function(e, ui) {\n            // digest all prepared changes\n            if (ui.item.sortable.resort && !ui.item.sortable.relocate) {\n\n              // Fetch saved and current position of dropped element\n              var end, start;\n              start = ui.item.sortable.index;\n              end = ui.item.index();\n              if (start < end)\n                end--;\n\n              // Reorder array and apply change to scope\n              ui.item.sortable.resort.$modelValue.splice(end, 0, ui.item.sortable.resort.$modelValue.splice(start, 1)[0]);\n\n            }\n            if (ui.item.sortable.resort || ui.item.sortable.relocate) {\n              scope.$apply();\n            }\n          };\n\n          // If user provided 'start' callback compose it with onStart function\n          _start = opts.start;\n          opts.start = function(e, ui) {\n            onStart(e, ui);\n            if (typeof _start === \"function\")\n              _start(e, ui);\n          };\n\n          // If user provided 'start' callback compose it with onStart function\n          _stop = opts.stop;\n          opts.stop = function(e, ui) {\n            onStop(e, ui);\n            if (typeof _stop === \"function\")\n              _stop(e, ui);\n          };\n\n          // If user provided 'update' callback compose it with onUpdate function\n          _update = opts.update;\n          opts.update = function(e, ui) {\n            onUpdate(e, ui);\n            if (typeof _update === \"function\")\n              _update(e, ui);\n          };\n\n          // If user provided 'receive' callback compose it with onReceive function\n          _receive = opts.receive;\n          opts.receive = function(e, ui) {\n            onReceive(e, ui);\n            if (typeof _receive === \"function\")\n              _receive(e, ui);\n          };\n\n          // If user provided 'remove' callback compose it with onRemove function\n          _remove = opts.remove;\n          opts.remove = function(e, ui) {\n            onRemove(e, ui);\n            if (typeof _remove === \"function\")\n              _remove(e, ui);\n          };\n        }\n\n        // Create sortable\n        element.sortable(opts);\n      }\n    };\n  }\n]);\n\n/**\n * Binds a TinyMCE widget to <textarea> elements.\n */\nangular.module('ui.directives').directive('uiTinymce', ['ui.config', function (uiConfig) {\n  uiConfig.tinymce = uiConfig.tinymce || {};\n  return {\n    require: 'ngModel',\n    link: function (scope, elm, attrs, ngModel) {\n      var expression,\n        options = {\n          // Update model on button click\n          onchange_callback: function (inst) {\n            if (inst.isDirty()) {\n              inst.save();\n              ngModel.$setViewValue(elm.val());\n              if (!scope.$$phase)\n                scope.$apply();\n            }\n          },\n          // Update model on keypress\n          handle_event_callback: function (e) {\n            if (this.isDirty()) {\n              this.save();\n              ngModel.$setViewValue(elm.val());\n              if (!scope.$$phase)\n                scope.$apply();\n            }\n            return true; // Continue handling\n          },\n          // Update model when calling setContent (such as from the source editor popup)\n          setup: function (ed) {\n            ed.onSetContent.add(function (ed, o) {\n              if (ed.isDirty()) {\n                ed.save();\n                ngModel.$setViewValue(elm.val());\n                if (!scope.$$phase)\n                  scope.$apply();\n              }\n            });\n          }\n        };\n      if (attrs.uiTinymce) {\n        expression = scope.$eval(attrs.uiTinymce);\n      } else {\n        expression = {};\n      }\n      angular.extend(options, uiConfig.tinymce, expression);\n      setTimeout(function () {\n        elm.tinymce(options);\n      });\n    }\n  };\n}]);\n\n/**\r\n * General-purpose validator for ngModel.\r\n * angular.js comes with several built-in validation mechanism for input fields (ngRequired, ngPattern etc.) but using\r\n * an arbitrary validation function requires creation of a custom formatters and / or parsers.\r\n * The ui-validate directive makes it easy to use any function(s) defined in scope as a validator function(s).\r\n * A validator function will trigger validation on both model and input changes.\r\n *\r\n * @example <input ui-validate=\" 'myValidatorFunction($value)' \">\r\n * @example <input ui-validate=\"{ foo : '$value > anotherModel', bar : 'validateFoo($value)' }\">\r\n * @example <input ui-validate=\"{ foo : '$value > anotherModel' }\" ui-validate-watch=\" 'anotherModel' \">\r\n * @example <input ui-validate=\"{ foo : '$value > anotherModel', bar : 'validateFoo($value)' }\" ui-validate-watch=\" { foo : 'anotherModel' } \">\r\n *\r\n * @param ui-validate {string|object literal} If strings is passed it should be a scope's function to be used as a validator.\r\n * If an object literal is passed a key denotes a validation error key while a value should be a validator function.\r\n * In both cases validator function should take a value to validate as its argument and should return true/false indicating a validation result.\r\n */\r\nangular.module('ui.directives').directive('uiValidate', function () {\r\n\r\n  return {\r\n    restrict: 'A',\r\n    require: 'ngModel',\r\n    link: function (scope, elm, attrs, ctrl) {\r\n      var validateFn, watch, validators = {},\r\n        validateExpr = scope.$eval(attrs.uiValidate);\r\n\r\n      if (!validateExpr) return;\r\n\r\n      if (angular.isString(validateExpr)) {\r\n        validateExpr = { validator: validateExpr };\r\n      }\r\n\r\n      angular.forEach(validateExpr, function (expression, key) {\r\n        validateFn = function (valueToValidate) {\r\n          if (scope.$eval(expression, { '$value' : valueToValidate })) {\r\n            ctrl.$setValidity(key, true);\r\n            return valueToValidate;\r\n          } else {\r\n            ctrl.$setValidity(key, false);\r\n            return undefined;\r\n          }\r\n        };\r\n        validators[key] = validateFn;\r\n        ctrl.$formatters.push(validateFn);\r\n        ctrl.$parsers.push(validateFn);\r\n      });\r\n\r\n      // Support for ui-validate-watch\r\n      if (attrs.uiValidateWatch) {\r\n        watch = scope.$eval(attrs.uiValidateWatch);\r\n        if (angular.isString(watch)) {\r\n          scope.$watch(watch, function(){\r\n            angular.forEach(validators, function(validatorFn, key){\r\n              validatorFn(ctrl.$modelValue);\r\n            });\r\n          });\r\n        } else {\r\n          angular.forEach(watch, function(expression, key){\r\n            scope.$watch(expression, function(){\r\n              validators[key](ctrl.$modelValue);\r\n            });\r\n          });\r\n        }\r\n      }\r\n    }\r\n  };\r\n});\n\n\n/**\n * A replacement utility for internationalization very similar to sprintf.\n *\n * @param replace {mixed} The tokens to replace depends on type\n *  string: all instances of $0 will be replaced\n *  array: each instance of $0, $1, $2 etc. will be placed with each array item in corresponding order\n *  object: all attributes will be iterated through, with :key being replaced with its corresponding value\n * @return string\n *\n * @example: 'Hello :name, how are you :day'.format({ name:'John', day:'Today' })\n * @example: 'Records $0 to $1 out of $2 total'.format(['10', '20', '3000'])\n * @example: '$0 agrees to all mentions $0 makes in the event that $0 hits a tree while $0 is driving drunk'.format('Bob')\n */\nangular.module('ui.filters').filter('format', function(){\n  return function(value, replace) {\n    if (!value) {\n      return value;\n    }\n    var target = value.toString(), token;\n    if (replace === undefined) {\n      return target;\n    }\n    if (!angular.isArray(replace) && !angular.isObject(replace)) {\n      return target.split('$0').join(replace);\n    }\n    token = angular.isArray(replace) && '$' || ':';\n\n    angular.forEach(replace, function(value, key){\n      target = target.split(token+key).join(value);\n    });\n    return target;\n  };\n});\n\n/**\n * Wraps the\n * @param text {string} haystack to search through\n * @param search {string} needle to search for\n * @param [caseSensitive] {boolean} optional boolean to use case-sensitive searching\n */\nangular.module('ui.filters').filter('highlight', function () {\n  return function (text, search, caseSensitive) {\n    if (search || angular.isNumber(search)) {\n      text = text.toString();\n      search = search.toString();\n      if (caseSensitive) {\n        return text.split(search).join('<span class=\"ui-match\">' + search + '</span>');\n      } else {\n        return text.replace(new RegExp(search, 'gi'), '<span class=\"ui-match\">$&</span>');\n      }\n    } else {\n      return text;\n    }\n  };\n});\n\n/**\n * Converts variable-esque naming conventions to something presentational, capitalized words separated by space.\n * @param {String} value The value to be parsed and prettified.\n * @param {String} [inflector] The inflector to use. Default: humanize.\n * @return {String}\n * @example {{ 'Here Is my_phoneNumber' | inflector:'humanize' }} => Here Is My Phone Number\n *          {{ 'Here Is my_phoneNumber' | inflector:'underscore' }} => here_is_my_phone_number\n *          {{ 'Here Is my_phoneNumber' | inflector:'variable' }} => hereIsMyPhoneNumber\n */\nangular.module('ui.filters').filter('inflector', function () {\n  function ucwords(text) {\n    return text.replace(/^([a-z])|\\s+([a-z])/g, function ($1) {\n      return $1.toUpperCase();\n    });\n  }\n\n  function breakup(text, separator) {\n    return text.replace(/[A-Z]/g, function (match) {\n      return separator + match;\n    });\n  }\n\n  var inflectors = {\n    humanize: function (value) {\n      return ucwords(breakup(value, ' ').split('_').join(' '));\n    },\n    underscore: function (value) {\n      return value.substr(0, 1).toLowerCase() + breakup(value.substr(1), '_').toLowerCase().split(' ').join('_');\n    },\n    variable: function (value) {\n      value = value.substr(0, 1).toLowerCase() + ucwords(value.split('_').join(' ')).substr(1).split(' ').join('');\n      return value;\n    }\n  };\n\n  return function (text, inflector, separator) {\n    if (inflector !== false && angular.isString(text)) {\n      inflector = inflector || 'humanize';\n      return inflectors[inflector](text);\n    } else {\n      return text;\n    }\n  };\n});\n\n/**\n * Filters out all duplicate items from an array by checking the specified key\n * @param [key] {string} the name of the attribute of each object to compare for uniqueness\n if the key is empty, the entire object will be compared\n if the key === false then no filtering will be performed\n * @return {array}\n */\nangular.module('ui.filters').filter('unique', function () {\n\n  return function (items, filterOn) {\n\n    if (filterOn === false) {\n      return items;\n    }\n\n    if ((filterOn || angular.isUndefined(filterOn)) && angular.isArray(items)) {\n      var hashCheck = {}, newItems = [];\n\n      var extractValueToCompare = function (item) {\n        if (angular.isObject(item) && angular.isString(filterOn)) {\n          return item[filterOn];\n        } else {\n          return item;\n        }\n      };\n\n      angular.forEach(items, function (item) {\n        var valueToCheck, isDuplicate = false;\n\n        for (var i = 0; i < newItems.length; i++) {\n          if (angular.equals(extractValueToCompare(newItems[i]), extractValueToCompare(item))) {\n            isDuplicate = true;\n            break;\n          }\n        }\n        if (!isDuplicate) {\n          newItems.push(item);\n        }\n\n      });\n      items = newItems;\n    }\n    return items;\n  };\n});\n"],[1,"angular.module(\"ui.bootstrap\", [\"ui.bootstrap.tpls\", \"ui.bootstrap.transition\",\"ui.bootstrap.collapse\",\"ui.bootstrap.accordion\",\"ui.bootstrap.alert\",\"ui.bootstrap.buttons\",\"ui.bootstrap.carousel\",\"ui.bootstrap.datepicker\",\"ui.bootstrap.dialog\",\"ui.bootstrap.dropdownToggle\",\"ui.bootstrap.modal\",\"ui.bootstrap.pagination\",\"ui.bootstrap.position\",\"ui.bootstrap.tooltip\",\"ui.bootstrap.popover\",\"ui.bootstrap.progressbar\",\"ui.bootstrap.rating\",\"ui.bootstrap.tabs\",\"ui.bootstrap.timepicker\",\"ui.bootstrap.typeahead\"]);\r\nangular.module(\"ui.bootstrap.tpls\", [\"template/accordion/accordion-group.html\",\"template/accordion/accordion.html\",\"template/alert/alert.html\",\"template/carousel/carousel.html\",\"template/carousel/slide.html\",\"template/datepicker/datepicker.html\",\"template/dialog/message.html\",\"template/pagination/pager.html\",\"template/pagination/pagination.html\",\"template/tooltip/tooltip-html-unsafe-popup.html\",\"template/tooltip/tooltip-popup.html\",\"template/popover/popover.html\",\"template/progressbar/bar.html\",\"template/progressbar/progress.html\",\"template/rating/rating.html\",\"template/tabs/tab.html\",\"template/tabs/tabset.html\",\"template/timepicker/timepicker.html\",\"template/typeahead/typeahead.html\"]);\r\nangular.module('ui.bootstrap.transition', [])\r\n\r\n/**\r\n * $transition service provides a consistent interface to trigger CSS 3 transitions and to be informed when they complete.\r\n * @param  {DOMElement} element  The DOMElement that will be animated.\r\n * @param  {string|object|function} trigger  The thing that will cause the transition to start:\r\n *   - As a string, it represents the css class to be added to the element.\r\n *   - As an object, it represents a hash of style attributes to be applied to the element.\r\n *   - As a function, it represents a function to be called that will cause the transition to occur.\r\n * @return {Promise}  A promise that is resolved when the transition finishes.\r\n */\r\n.factory('$transition', ['$q', '$timeout', '$rootScope', function($q, $timeout, $rootScope) {\r\n\r\n  var $transition = function(element, trigger, options) {\r\n    options = options || {};\r\n    var deferred = $q.defer();\r\n    var endEventName = $transition[options.animation ? \"animationEndEventName\" : \"transitionEndEventName\"];\r\n\r\n    var transitionEndHandler = function(event) {\r\n      $rootScope.$apply(function() {\r\n        element.unbind(endEventName, transitionEndHandler);\r\n        deferred.resolve(element);\r\n      });\r\n    };\r\n\r\n    if (endEventName) {\r\n      element.bind(endEventName, transitionEndHandler);\r\n    }\r\n\r\n    // Wrap in a timeout to allow the browser time to update the DOM before the transition is to occur\r\n    $timeout(function() {\r\n      if ( angular.isString(trigger) ) {\r\n        element.addClass(trigger);\r\n      } else if ( angular.isFunction(trigger) ) {\r\n        trigger(element);\r\n      } else if ( angular.isObject(trigger) ) {\r\n        element.css(trigger);\r\n      }\r\n      //If browser does not support transitions, instantly resolve\r\n      if ( !endEventName ) {\r\n        deferred.resolve(element);\r\n      }\r\n    });\r\n\r\n    // Add our custom cancel function to the promise that is returned\r\n    // We can call this if we are about to run a new transition, which we know will prevent this transition from ending,\r\n    // i.e. it will therefore never raise a transitionEnd event for that transition\r\n    deferred.promise.cancel = function() {\r\n      if ( endEventName ) {\r\n        element.unbind(endEventName, transitionEndHandler);\r\n      }\r\n      deferred.reject('Transition cancelled');\r\n    };\r\n\r\n    return deferred.promise;\r\n  };\r\n\r\n  // Work out the name of the transitionEnd event\r\n  var transElement = document.createElement('trans');\r\n  var transitionEndEventNames = {\r\n    'WebkitTransition': 'webkitTransitionEnd',\r\n    'MozTransition': 'transitionend',\r\n    'OTransition': 'oTransitionEnd',\r\n    'transition': 'transitionend'\r\n  };\r\n  var animationEndEventNames = {\r\n    'WebkitTransition': 'webkitAnimationEnd',\r\n    'MozTransition': 'animationend',\r\n    'OTransition': 'oAnimationEnd',\r\n    'transition': 'animationend'\r\n  };\r\n  function findEndEventName(endEventNames) {\r\n    for (var name in endEventNames){\r\n      if (transElement.style[name] !== undefined) {\r\n        return endEventNames[name];\r\n      }\r\n    }\r\n  }\r\n  $transition.transitionEndEventName = findEndEventName(transitionEndEventNames);\r\n  $transition.animationEndEventName = findEndEventName(animationEndEventNames);\r\n  return $transition;\r\n}]);\r\n\r\nangular.module('ui.bootstrap.collapse',['ui.bootstrap.transition'])\r\n\r\n// The collapsible directive indicates a block of html that will expand and collapse\r\n.directive('collapse', ['$transition', function($transition) {\r\n  // CSS transitions don't work with height: auto, so we have to manually change the height to a\r\n  // specific value and then once the animation completes, we can reset the height to auto.\r\n  // Unfortunately if you do this while the CSS transitions are specified (i.e. in the CSS class\r\n  // \"collapse\") then you trigger a change to height 0 in between.\r\n  // The fix is to remove the \"collapse\" CSS class while changing the height back to auto - phew!\r\n  var fixUpHeight = function(scope, element, height) {\r\n    // We remove the collapse CSS class to prevent a transition when we change to height: auto\r\n    element.removeClass('collapse');\r\n    element.css({ height: height });\r\n    // It appears that  reading offsetWidth makes the browser realise that we have changed the\r\n    // height already :-/\r\n    var x = element[0].offsetWidth;\r\n    element.addClass('collapse');\r\n  };\r\n\r\n  return {\r\n    link: function(scope, element, attrs) {\r\n\r\n      var isCollapsed;\r\n      var initialAnimSkip = true;\r\n      scope.$watch(function (){ return element[0].scrollHeight; }, function (value) {\r\n        //The listener is called when scollHeight changes\r\n        //It actually does on 2 scenarios: \r\n        // 1. Parent is set to display none\r\n        // 2. angular bindings inside are resolved\r\n        //When we have a change of scrollHeight we are setting again the correct height if the group is opened\r\n        if (element[0].scrollHeight !== 0) {\r\n          if (!isCollapsed) {\r\n            if (initialAnimSkip) {\r\n              fixUpHeight(scope, element, element[0].scrollHeight + 'px');\r\n            } else {\r\n              fixUpHeight(scope, element, 'auto');\r\n            }\r\n          }\r\n        }\r\n      });\r\n      \r\n      scope.$watch(attrs.collapse, function(value) {\r\n        if (value) {\r\n          collapse();\r\n        } else {\r\n          expand();\r\n        }\r\n      });\r\n      \r\n\r\n      var currentTransition;\r\n      var doTransition = function(change) {\r\n        if ( currentTransition ) {\r\n          currentTransition.cancel();\r\n        }\r\n        currentTransition = $transition(element,change);\r\n        currentTransition.then(\r\n          function() { currentTransition = undefined; },\r\n          function() { currentTransition = undefined; }\r\n        );\r\n        return currentTransition;\r\n      };\r\n\r\n      var expand = function() {\r\n        if (initialAnimSkip) {\r\n          initialAnimSkip = false;\r\n          if ( !isCollapsed ) {\r\n            fixUpHeight(scope, element, 'auto');\r\n          }\r\n        } else {\r\n          doTransition({ height : element[0].scrollHeight + 'px' })\r\n          .then(function() {\r\n            // This check ensures that we don't accidentally update the height if the user has closed\r\n            // the group while the animation was still running\r\n            if ( !isCollapsed ) {\r\n              fixUpHeight(scope, element, 'auto');\r\n            }\r\n          });\r\n        }\r\n        isCollapsed = false;\r\n      };\r\n      \r\n      var collapse = function() {\r\n        isCollapsed = true;\r\n        if (initialAnimSkip) {\r\n          initialAnimSkip = false;\r\n          fixUpHeight(scope, element, 0);\r\n        } else {\r\n          fixUpHeight(scope, element, element[0].scrollHeight + 'px');\r\n          doTransition({'height':'0'});\r\n        }\r\n      };\r\n    }\r\n  };\r\n}]);\r\n\r\nangular.module('ui.bootstrap.accordion', ['ui.bootstrap.collapse'])\r\n\r\n.constant('accordionConfig', {\r\n  closeOthers: true\r\n})\r\n\r\n.controller('AccordionController', ['$scope', '$attrs', 'accordionConfig', function ($scope, $attrs, accordionConfig) {\r\n  \r\n  // This array keeps track of the accordion groups\r\n  this.groups = [];\r\n\r\n  // Ensure that all the groups in this accordion are closed, unless close-others explicitly says not to\r\n  this.closeOthers = function(openGroup) {\r\n    var closeOthers = angular.isDefined($attrs.closeOthers) ? $scope.$eval($attrs.closeOthers) : accordionConfig.closeOthers;\r\n    if ( closeOthers ) {\r\n      angular.forEach(this.groups, function (group) {\r\n        if ( group !== openGroup ) {\r\n          group.isOpen = false;\r\n        }\r\n      });\r\n    }\r\n  };\r\n  \r\n  // This is called from the accordion-group directive to add itself to the accordion\r\n  this.addGroup = function(groupScope) {\r\n    var that = this;\r\n    this.groups.push(groupScope);\r\n\r\n    groupScope.$on('$destroy', function (event) {\r\n      that.removeGroup(groupScope);\r\n    });\r\n  };\r\n\r\n  // This is called from the accordion-group directive when to remove itself\r\n  this.removeGroup = function(group) {\r\n    var index = this.groups.indexOf(group);\r\n    if ( index !== -1 ) {\r\n      this.groups.splice(this.groups.indexOf(group), 1);\r\n    }\r\n  };\r\n\r\n}])\r\n\r\n// The accordion directive simply sets up the directive controller\r\n// and adds an accordion CSS class to itself element.\r\n.directive('accordion', function () {\r\n  return {\r\n    restrict:'EA',\r\n    controller:'AccordionController',\r\n    transclude: true,\r\n    replace: false,\r\n    templateUrl: 'template/accordion/accordion.html'\r\n  };\r\n})\r\n\r\n// The accordion-group directive indicates a block of html that will expand and collapse in an accordion\r\n.directive('accordionGroup', ['$parse', '$transition', '$timeout', function($parse, $transition, $timeout) {\r\n  return {\r\n    require:'^accordion',         // We need this directive to be inside an accordion\r\n    restrict:'EA',\r\n    transclude:true,              // It transcludes the contents of the directive into the template\r\n    replace: true,                // The element containing the directive will be replaced with the template\r\n    templateUrl:'template/accordion/accordion-group.html',\r\n    scope:{ heading:'@' },        // Create an isolated scope and interpolate the heading attribute onto this scope\r\n    controller: ['$scope', function($scope) {\r\n      this.setHeading = function(element) {\r\n        this.heading = element;\r\n      };\r\n    }],\r\n    link: function(scope, element, attrs, accordionCtrl) {\r\n      var getIsOpen, setIsOpen;\r\n\r\n      accordionCtrl.addGroup(scope);\r\n\r\n      scope.isOpen = false;\r\n      \r\n      if ( attrs.isOpen ) {\r\n        getIsOpen = $parse(attrs.isOpen);\r\n        setIsOpen = getIsOpen.assign;\r\n\r\n        scope.$watch(\r\n          function watchIsOpen() { return getIsOpen(scope.$parent); },\r\n          function updateOpen(value) { scope.isOpen = value; }\r\n        );\r\n        \r\n        scope.isOpen = getIsOpen ? getIsOpen(scope.$parent) : false;\r\n      }\r\n\r\n      scope.$watch('isOpen', function(value) {\r\n        if ( value ) {\r\n          accordionCtrl.closeOthers(scope);\r\n        }\r\n        if ( setIsOpen ) {\r\n          setIsOpen(scope.$parent, value);\r\n        }\r\n      });\r\n    }\r\n  };\r\n}])\r\n\r\n// Use accordion-heading below an accordion-group to provide a heading containing HTML\r\n// <accordion-group>\r\n//   <accordion-heading>Heading containing HTML - <img src=\"...\"></accordion-heading>\r\n// </accordion-group>\r\n.directive('accordionHeading', function() {\r\n  return {\r\n    restrict: 'EA',\r\n    transclude: true,   // Grab the contents to be used as the heading\r\n    template: '',       // In effect remove this element!\r\n    replace: true,\r\n    require: '^accordionGroup',\r\n    compile: function(element, attr, transclude) {\r\n      return function link(scope, element, attr, accordionGroupCtrl) {\r\n        // Pass the heading to the accordion-group controller\r\n        // so that it can be transcluded into the right place in the template\r\n        // [The second parameter to transclude causes the elements to be cloned so that they work in ng-repeat]\r\n        accordionGroupCtrl.setHeading(transclude(scope, function() {}));\r\n      };\r\n    }\r\n  };\r\n})\r\n\r\n// Use in the accordion-group template to indicate where you want the heading to be transcluded\r\n// You must provide the property on the accordion-group controller that will hold the transcluded element\r\n// <div class=\"accordion-group\">\r\n//   <div class=\"accordion-heading\" ><a ... accordion-transclude=\"heading\">...</a></div>\r\n//   ...\r\n// </div>\r\n.directive('accordionTransclude', function() {\r\n  return {\r\n    require: '^accordionGroup',\r\n    link: function(scope, element, attr, controller) {\r\n      scope.$watch(function() { return controller[attr.accordionTransclude]; }, function(heading) {\r\n        if ( heading ) {\r\n          element.html('');\r\n          element.append(heading);\r\n        }\r\n      });\r\n    }\r\n  };\r\n});\r\n\r\nangular.module(\"ui.bootstrap.alert\", []).directive('alert', function () {\r\n  return {\r\n    restrict:'EA',\r\n    templateUrl:'template/alert/alert.html',\r\n    transclude:true,\r\n    replace:true,\r\n    scope: {\r\n      type: '=',\r\n      close: '&'\r\n    },\r\n    link: function(scope, iElement, iAttrs, controller) {\r\n      scope.closeable = \"close\" in iAttrs;\r\n    }\r\n  };\r\n});\r\n\r\nangular.module('ui.bootstrap.buttons', [])\r\n\r\n  .constant('buttonConfig', {\r\n    activeClass:'active',\r\n    toggleEvent:'click'\r\n  })\r\n\r\n  .directive('btnRadio', ['buttonConfig', function (buttonConfig) {\r\n  var activeClass = buttonConfig.activeClass || 'active';\r\n  var toggleEvent = buttonConfig.toggleEvent || 'click';\r\n\r\n  return {\r\n\r\n    require:'ngModel',\r\n    link:function (scope, element, attrs, ngModelCtrl) {\r\n\r\n      //model -> UI\r\n      ngModelCtrl.$render = function () {\r\n        element.toggleClass(activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.btnRadio)));\r\n      };\r\n\r\n      //ui->model\r\n      element.bind(toggleEvent, function () {\r\n        if (!element.hasClass(activeClass)) {\r\n          scope.$apply(function () {\r\n            ngModelCtrl.$setViewValue(scope.$eval(attrs.btnRadio));\r\n            ngModelCtrl.$render();\r\n          });\r\n        }\r\n      });\r\n    }\r\n  };\r\n}])\r\n\r\n  .directive('btnCheckbox', ['buttonConfig', function (buttonConfig) {\r\n\r\n  var activeClass = buttonConfig.activeClass || 'active';\r\n  var toggleEvent = buttonConfig.toggleEvent || 'click';\r\n\r\n  return {\r\n    require:'ngModel',\r\n    link:function (scope, element, attrs, ngModelCtrl) {\r\n\r\n      var trueValue = scope.$eval(attrs.btnCheckboxTrue);\r\n      var falseValue = scope.$eval(attrs.btnCheckboxFalse);\r\n\r\n      trueValue = angular.isDefined(trueValue) ? trueValue : true;\r\n      falseValue = angular.isDefined(falseValue) ? falseValue : false;\r\n\r\n      //model -> UI\r\n      ngModelCtrl.$render = function () {\r\n        element.toggleClass(activeClass, angular.equals(ngModelCtrl.$modelValue, trueValue));\r\n      };\r\n\r\n      //ui->model\r\n      element.bind(toggleEvent, function () {\r\n        scope.$apply(function () {\r\n          ngModelCtrl.$setViewValue(element.hasClass(activeClass) ? falseValue : trueValue);\r\n          ngModelCtrl.$render();\r\n        });\r\n      });\r\n    }\r\n  };\r\n}]);\r\n/**\r\n* @ngdoc overview\r\n* @name ui.bootstrap.carousel\r\n* \r\n* @description\r\n* AngularJS version of an image carousel.\r\n*\r\n*/\r\nangular.module('ui.bootstrap.carousel', ['ui.bootstrap.transition'])\r\n.controller('CarouselController', ['$scope', '$timeout', '$transition', '$q', function ($scope, $timeout, $transition, $q) {\r\n  var self = this,\r\n    slides = self.slides = [],\r\n    currentIndex = -1,\r\n    currentTimeout, isPlaying;\r\n  self.currentSlide = null;\r\n\r\n  /* direction: \"prev\" or \"next\" */\r\n  self.select = function(nextSlide, direction) {\r\n    var nextIndex = slides.indexOf(nextSlide);\r\n    //Decide direction if it's not given\r\n    if (direction === undefined) {\r\n      direction = nextIndex > currentIndex ? \"next\" : \"prev\";\r\n    }\r\n    if (nextSlide && nextSlide !== self.currentSlide) {\r\n      if ($scope.$currentTransition) {\r\n        $scope.$currentTransition.cancel();\r\n        //Timeout so ng-class in template has time to fix classes for finished slide\r\n        $timeout(goNext);\r\n      } else {\r\n        goNext();\r\n      }\r\n    }\r\n    function goNext() {\r\n      //If we have a slide to transition from and we have a transition type and we're allowed, go\r\n      if (self.currentSlide && angular.isString(direction) && !$scope.noTransition && nextSlide.$element) { \r\n        //We shouldn't do class manip in here, but it's the same weird thing bootstrap does. need to fix sometime\r\n        nextSlide.$element.addClass(direction);\r\n        nextSlide.$element[0].offsetWidth = nextSlide.$element[0].offsetWidth; //force reflow\r\n\r\n        //Set all other slides to stop doing their stuff for the new transition\r\n        angular.forEach(slides, function(slide) {\r\n          angular.extend(slide, {direction: '', entering: false, leaving: false, active: false});\r\n        });\r\n        angular.extend(nextSlide, {direction: direction, active: true, entering: true});\r\n        angular.extend(self.currentSlide||{}, {direction: direction, leaving: true});\r\n\r\n        $scope.$currentTransition = $transition(nextSlide.$element, {});\r\n        //We have to create new pointers inside a closure since next & current will change\r\n        (function(next,current) {\r\n          $scope.$currentTransition.then(\r\n            function(){ transitionDone(next, current); },\r\n            function(){ transitionDone(next, current); }\r\n          );\r\n        }(nextSlide, self.currentSlide));\r\n      } else {\r\n        transitionDone(nextSlide, self.currentSlide);\r\n      }\r\n      self.currentSlide = nextSlide;\r\n      currentIndex = nextIndex;\r\n      //every time you change slides, reset the timer\r\n      restartTimer();\r\n    }\r\n    function transitionDone(next, current) {\r\n      angular.extend(next, {direction: '', active: true, leaving: false, entering: false});\r\n      angular.extend(current||{}, {direction: '', active: false, leaving: false, entering: false});\r\n      $scope.$currentTransition = null;\r\n    }\r\n  };\r\n\r\n  /* Allow outside people to call indexOf on slides array */\r\n  self.indexOfSlide = function(slide) {\r\n    return slides.indexOf(slide);\r\n  };\r\n\r\n  $scope.next = function() {\r\n    var newIndex = (currentIndex + 1) % slides.length;\r\n    \r\n    //Prevent this user-triggered transition from occurring if there is already one in progress\r\n    if (!$scope.$currentTransition) {\r\n      return self.select(slides[newIndex], 'next');\r\n    }\r\n  };\r\n\r\n  $scope.prev = function() {\r\n    var newIndex = currentIndex - 1 < 0 ? slides.length - 1 : currentIndex - 1;\r\n    \r\n    //Prevent this user-triggered transition from occurring if there is already one in progress\r\n    if (!$scope.$currentTransition) {\r\n      return self.select(slides[newIndex], 'prev');\r\n    }\r\n  };\r\n\r\n  $scope.select = function(slide) {\r\n    self.select(slide);\r\n  };\r\n\r\n  $scope.isActive = function(slide) {\r\n     return self.currentSlide === slide;\r\n  };\r\n\r\n  $scope.slides = function() {\r\n    return slides;\r\n  };\r\n\r\n  $scope.$watch('interval', restartTimer);\r\n  function restartTimer() {\r\n    if (currentTimeout) {\r\n      $timeout.cancel(currentTimeout);\r\n    }\r\n    function go() {\r\n      if (isPlaying) {\r\n        $scope.next();\r\n        restartTimer();\r\n      } else {\r\n        $scope.pause();\r\n      }\r\n    }\r\n    var interval = +$scope.interval;\r\n    if (!isNaN(interval) && interval>=0) {\r\n      currentTimeout = $timeout(go, interval);\r\n    }\r\n  }\r\n  $scope.play = function() {\r\n    if (!isPlaying) {\r\n      isPlaying = true;\r\n      restartTimer();\r\n    }\r\n  };\r\n  $scope.pause = function() {\r\n    if (!$scope.noPause) {\r\n      isPlaying = false;\r\n      if (currentTimeout) {\r\n        $timeout.cancel(currentTimeout);\r\n      }\r\n    }\r\n  };\r\n\r\n  self.addSlide = function(slide, element) {\r\n    slide.$element = element;\r\n    slides.push(slide);\r\n    //if this is the first slide or the slide is set to active, select it\r\n    if(slides.length === 1 || slide.active) {\r\n      self.select(slides[slides.length-1]);\r\n      if (slides.length == 1) {\r\n        $scope.play();\r\n      }\r\n    } else {\r\n      slide.active = false;\r\n    }\r\n  };\r\n\r\n  self.removeSlide = function(slide) {\r\n    //get the index of the slide inside the carousel\r\n    var index = slides.indexOf(slide);\r\n    slides.splice(index, 1);\r\n    if (slides.length > 0 && slide.active) {\r\n      if (index >= slides.length) {\r\n        self.select(slides[index-1]);\r\n      } else {\r\n        self.select(slides[index]);\r\n      }\r\n    } else if (currentIndex > index) {\r\n      currentIndex--;\r\n    }\r\n  };\r\n}])\r\n\r\n/**\r\n * @ngdoc directive\r\n * @name ui.bootstrap.carousel.directive:carousel\r\n * @restrict EA\r\n *\r\n * @description\r\n * Carousel is the outer container for a set of image 'slides' to showcase.\r\n *\r\n * @param {number=} interval The time, in milliseconds, that it will take the carousel to go to the next slide.\r\n * @param {boolean=} noTransition Whether to disable transitions on the carousel.\r\n * @param {boolean=} noPause Whether to disable pausing on the carousel (by default, the carousel interval pauses on hover).\r\n *\r\n * @example\r\n<example module=\"ui.bootstrap\">\r\n  <file name=\"index.html\">\r\n    <carousel>\r\n      <slide>\r\n        <img src=\"http://placekitten.com/150/150\" style=\"margin:auto;\">\r\n        <div class=\"carousel-caption\">\r\n          <p>Beautiful!</p>\r\n        </div>\r\n      </slide>\r\n      <slide>\r\n        <img src=\"http://placekitten.com/100/150\" style=\"margin:auto;\">\r\n        <div class=\"carousel-caption\">\r\n          <p>D'aww!</p>\r\n        </div>\r\n      </slide>\r\n    </carousel>\r\n  </file>\r\n  <file name=\"demo.css\">\r\n    .carousel-indicators {\r\n      top: auto;\r\n      bottom: 15px;\r\n    }\r\n  </file>\r\n</example>\r\n */\r\n.directive('carousel', [function() {\r\n  return {\r\n    restrict: 'EA',\r\n    transclude: true,\r\n    replace: true,\r\n    controller: 'CarouselController',\r\n    require: 'carousel',\r\n    templateUrl: 'template/carousel/carousel.html',\r\n    scope: {\r\n      interval: '=',\r\n      noTransition: '=',\r\n      noPause: '='\r\n    }\r\n  };\r\n}])\r\n\r\n/**\r\n * @ngdoc directive\r\n * @name ui.bootstrap.carousel.directive:slide\r\n * @restrict EA\r\n *\r\n * @description\r\n * Creates a slide inside a {@link ui.bootstrap.carousel.directive:carousel carousel}.  Must be placed as a child of a carousel element.\r\n *\r\n * @param {boolean=} active Model binding, whether or not this slide is currently active.\r\n *\r\n * @example\r\n<example module=\"ui.bootstrap\">\r\n  <file name=\"index.html\">\r\n<div ng-controller=\"CarouselDemoCtrl\">\r\n  <carousel>\r\n    <slide ng-repeat=\"slide in slides\" active=\"slide.active\">\r\n      <img ng-src=\"{{slide.image}}\" style=\"margin:auto;\">\r\n      <div class=\"carousel-caption\">\r\n        <h4>Slide {{$index}}</h4>\r\n        <p>{{slide.text}}</p>\r\n      </div>\r\n    </slide>\r\n  </carousel>\r\n  <div class=\"row-fluid\">\r\n    <div class=\"span6\">\r\n      <ul>\r\n        <li ng-repeat=\"slide in slides\">\r\n          <button class=\"btn btn-mini\" ng-class=\"{'btn-info': !slide.active, 'btn-success': slide.active}\" ng-disabled=\"slide.active\" ng-click=\"slide.active = true\">select</button>\r\n          {{$index}}: {{slide.text}}\r\n        </li>\r\n      </ul>\r\n      <a class=\"btn\" ng-click=\"addSlide()\">Add Slide</a>\r\n    </div>\r\n    <div class=\"span6\">\r\n      Interval, in milliseconds: <input type=\"number\" ng-model=\"myInterval\">\r\n      <br />Enter a negative number to stop the interval.\r\n    </div>\r\n  </div>\r\n</div>\r\n  </file>\r\n  <file name=\"script.js\">\r\nfunction CarouselDemoCtrl($scope) {\r\n  $scope.myInterval = 5000;\r\n  var slides = $scope.slides = [];\r\n  $scope.addSlide = function() {\r\n    var newWidth = 200 + ((slides.length + (25 * slides.length)) % 150);\r\n    slides.push({\r\n      image: 'http://placekitten.com/' + newWidth + '/200',\r\n      text: ['More','Extra','Lots of','Surplus'][slides.length % 4] + ' '\r\n        ['Cats', 'Kittys', 'Felines', 'Cutes'][slides.length % 4]\r\n    });\r\n  };\r\n  for (var i=0; i<4; i++) $scope.addSlide();\r\n}\r\n  </file>\r\n  <file name=\"demo.css\">\r\n    .carousel-indicators {\r\n      top: auto;\r\n      bottom: 15px;\r\n    }\r\n  </file>\r\n</example>\r\n*/\r\n\r\n.directive('slide', ['$parse', function($parse) {\r\n  return {\r\n    require: '^carousel',\r\n    restrict: 'EA',\r\n    transclude: true,\r\n    replace: true,\r\n    templateUrl: 'template/carousel/slide.html',\r\n    scope: {\r\n    },\r\n    link: function (scope, element, attrs, carouselCtrl) {\r\n      //Set up optional 'active' = binding\r\n      if (attrs.active) {\r\n        var getActive = $parse(attrs.active);\r\n        var setActive = getActive.assign;\r\n        var lastValue = scope.active = getActive(scope.$parent);\r\n        scope.$watch(function parentActiveWatch() {\r\n          var parentActive = getActive(scope.$parent);\r\n          \r\n          if (parentActive !== scope.active) {\r\n            // we are out of sync and need to copy\r\n            if (parentActive !== lastValue) {\r\n              // parent changed and it has precedence\r\n              lastValue = scope.active = parentActive;\r\n            } else {\r\n              // if the parent can be assigned then do so\r\n              setActive(scope.$parent, parentActive = lastValue = scope.active);\r\n            }\r\n          }\r\n          return parentActive;\r\n        });\r\n      }\r\n\r\n      carouselCtrl.addSlide(scope, element);\r\n      //when the scope is destroyed then remove the slide from the current slides array\r\n      scope.$on('$destroy', function() {\r\n        carouselCtrl.removeSlide(scope);\r\n      });\r\n\r\n      scope.$watch('active', function(active) {\r\n        if (active) {\r\n          carouselCtrl.select(scope);\r\n        }\r\n      });\r\n    }\r\n  };\r\n}]);\r\n\r\nangular.module('ui.bootstrap.datepicker', [])\r\n\r\n.constant('datepickerConfig', {\r\n  dayFormat: 'dd',\r\n  monthFormat: 'MMMM',\r\n  yearFormat: 'yyyy',\r\n  dayHeaderFormat: 'EEE',\r\n  dayTitleFormat: 'MMMM yyyy',\r\n  monthTitleFormat: 'yyyy',\r\n  showWeeks: true,\r\n  startingDay: 0,\r\n  yearRange: 20\r\n})\r\n\r\n.directive( 'datepicker', ['dateFilter', '$parse', 'datepickerConfig', function (dateFilter, $parse, datepickerConfig) {\r\n  return {\r\n    restrict: 'EA',\r\n    replace: true,\r\n    scope: {\r\n      model: '=ngModel',\r\n      dateDisabled: '&'\r\n    },\r\n    templateUrl: 'template/datepicker/datepicker.html',\r\n    link: function(scope, element, attrs) {\r\n      scope.mode = 'day'; // Initial mode\r\n\r\n      // Configuration parameters\r\n      var selected = new Date(), showWeeks, minDate, maxDate, format = {};\r\n      format.day   = angular.isDefined(attrs.dayFormat) ? scope.$eval(attrs.dayFormat) : datepickerConfig.dayFormat;\r\n      format.month = angular.isDefined(attrs.monthFormat) ? scope.$eval(attrs.monthFormat) : datepickerConfig.monthFormat;\r\n      format.year  = angular.isDefined(attrs.yearFormat) ? scope.$eval(attrs.yearFormat) : datepickerConfig.yearFormat;\r\n      format.dayHeader  = angular.isDefined(attrs.dayHeaderFormat) ? scope.$eval(attrs.dayHeaderFormat) : datepickerConfig.dayHeaderFormat;\r\n      format.dayTitle   = angular.isDefined(attrs.dayTitleFormat) ? scope.$eval(attrs.dayTitleFormat) : datepickerConfig.dayTitleFormat;\r\n      format.monthTitle = angular.isDefined(attrs.monthTitleFormat) ? scope.$eval(attrs.monthTitleFormat) : datepickerConfig.monthTitleFormat;\r\n      var startingDay   = angular.isDefined(attrs.startingDay) ? scope.$eval(attrs.startingDay) : datepickerConfig.startingDay;\r\n      var yearRange = angular.isDefined(attrs.yearRange) ? scope.$eval(attrs.yearRange) : datepickerConfig.yearRange;\r\n\r\n      if (attrs.showWeeks) {\r\n        scope.$parent.$watch($parse(attrs.showWeeks), function(value) {\r\n          showWeeks = !! value;\r\n          updateShowWeekNumbers();\r\n        });\r\n      } else {\r\n        showWeeks = datepickerConfig.showWeeks;\r\n        updateShowWeekNumbers();\r\n      }\r\n\r\n      if (attrs.min) {\r\n        scope.$parent.$watch($parse(attrs.min), function(value) {\r\n          minDate = new Date(value);\r\n          refill();\r\n        });\r\n      }\r\n      if (attrs.max) {\r\n        scope.$parent.$watch($parse(attrs.max), function(value) {\r\n          maxDate = new Date(value);\r\n          refill();\r\n        });\r\n      }\r\n\r\n      function updateCalendar (rows, labels, title) {\r\n        scope.rows = rows;\r\n        scope.labels = labels;\r\n        scope.title = title;\r\n      }\r\n\r\n      // Define whether the week number are visible\r\n      function updateShowWeekNumbers() {\r\n        scope.showWeekNumbers = ( scope.mode === 'day' && showWeeks );\r\n      }\r\n\r\n      function compare( date1, date2 ) {\r\n        if ( scope.mode === 'year') {\r\n          return date2.getFullYear() - date1.getFullYear();\r\n        } else if ( scope.mode === 'month' ) {\r\n          return new Date( date2.getFullYear(), date2.getMonth() ) - new Date( date1.getFullYear(), date1.getMonth() );\r\n        } else if ( scope.mode === 'day' ) {\r\n          return (new Date( date2.getFullYear(), date2.getMonth(), date2.getDate() ) - new Date( date1.getFullYear(), date1.getMonth(), date1.getDate() ) );\r\n        }\r\n      }\r\n\r\n      function isDisabled(date) {\r\n        return ((minDate && compare(date, minDate) > 0) || (maxDate && compare(date, maxDate) < 0) || (scope.dateDisabled && scope.dateDisabled({ date: date, mode: scope.mode })));\r\n      }\r\n\r\n      // Split array into smaller arrays\r\n      var split = function(a, size) {\r\n        var arrays = [];\r\n        while (a.length > 0) {\r\n          arrays.push(a.splice(0, size));\r\n        }\r\n        return arrays;\r\n      };\r\n      var getDaysInMonth = function( year, month ) {\r\n        return new Date(year, month + 1, 0).getDate();\r\n      };\r\n\r\n      var fill = {\r\n        day: function() {\r\n          var days = [], labels = [], lastDate = null;\r\n\r\n          function addDays( dt, n, isCurrentMonth ) {\r\n            for (var i =0; i < n; i ++) {\r\n              days.push( {date: new Date(dt), isCurrent: isCurrentMonth, isSelected: isSelected(dt), label: dateFilter(dt, format.day), disabled: isDisabled(dt) } );\r\n              dt.setDate( dt.getDate() + 1 );\r\n            }\r\n            lastDate = dt;\r\n          }\r\n\r\n          var d = new Date(selected);\r\n          d.setDate(1);\r\n\r\n          var difference = startingDay - d.getDay();\r\n          var numDisplayedFromPreviousMonth = (difference > 0) ? 7 - difference : - difference;\r\n\r\n          if ( numDisplayedFromPreviousMonth > 0 ) {\r\n            d.setDate( - numDisplayedFromPreviousMonth + 1 );\r\n            addDays(d, numDisplayedFromPreviousMonth, false);\r\n          }\r\n          addDays(lastDate || d, getDaysInMonth(selected.getFullYear(), selected.getMonth()), true);\r\n          addDays(lastDate, (7 - days.length % 7) % 7, false);\r\n\r\n          // Day labels\r\n          for (i = 0; i < 7; i++) {\r\n            labels.push(  dateFilter(days[i].date, format.dayHeader) );\r\n          }\r\n          updateCalendar( split( days, 7 ), labels, dateFilter(selected, format.dayTitle) );\r\n        },\r\n        month: function() {\r\n          var months = [], i = 0, year = selected.getFullYear();\r\n          while ( i < 12 ) {\r\n            var dt = new Date(year, i++, 1);\r\n            months.push( {date: dt, isCurrent: true, isSelected: isSelected(dt), label: dateFilter(dt, format.month), disabled: isDisabled(dt)} );\r\n          }\r\n          updateCalendar( split( months, 3 ), [], dateFilter(selected, format.monthTitle) );\r\n        },\r\n        year: function() {\r\n          var years = [], year = parseInt((selected.getFullYear() - 1) / yearRange, 10) * yearRange + 1;\r\n          for ( var i = 0; i < yearRange; i++ ) {\r\n            var dt = new Date(year + i, 0, 1);\r\n            years.push( {date: dt, isCurrent: true, isSelected: isSelected(dt), label: dateFilter(dt, format.year), disabled: isDisabled(dt)} );\r\n          }\r\n          var title = years[0].label + ' - ' + years[years.length - 1].label;\r\n          updateCalendar( split( years, 5 ), [], title );\r\n        }\r\n      };\r\n      var refill = function() {\r\n        fill[scope.mode]();\r\n      };\r\n      var isSelected = function( dt ) {\r\n        if ( scope.model && scope.model.getFullYear() === dt.getFullYear() ) {\r\n          if ( scope.mode === 'year' ) {\r\n            return true;\r\n          }\r\n          if ( scope.model.getMonth() === dt.getMonth() ) {\r\n            return ( scope.mode === 'month' || (scope.mode === 'day' && scope.model.getDate() === dt.getDate()) );\r\n          }\r\n        }\r\n        return false;\r\n      };\r\n\r\n      scope.$watch('model', function ( dt, olddt ) {\r\n        if ( angular.isDate(dt) ) {\r\n          selected = angular.copy(dt);\r\n        }\r\n\r\n        if ( ! angular.equals(dt, olddt) ) {\r\n          refill();\r\n        }\r\n      });\r\n      scope.$watch('mode', function() {\r\n        updateShowWeekNumbers();\r\n        refill();\r\n      });\r\n\r\n      scope.select = function( dt ) {\r\n        selected = new Date(dt);\r\n\r\n        if ( scope.mode === 'year' ) {\r\n          scope.mode = 'month';\r\n          selected.setFullYear( dt.getFullYear() );\r\n        } else if ( scope.mode === 'month' ) {\r\n          scope.mode = 'day';\r\n          selected.setMonth( dt.getMonth() );\r\n        } else if ( scope.mode === 'day' ) {\r\n          scope.model = new Date(selected);\r\n        }\r\n      };\r\n      scope.move = function(step) {\r\n        if (scope.mode === 'day') {\r\n          selected.setMonth( selected.getMonth() + step );\r\n        } else if (scope.mode === 'month') {\r\n          selected.setFullYear( selected.getFullYear() + step );\r\n        } else if (scope.mode === 'year') {\r\n          selected.setFullYear( selected.getFullYear() + step * yearRange );\r\n        }\r\n        refill();\r\n      };\r\n      scope.toggleMode = function() {\r\n        scope.mode = ( scope.mode === 'day' ) ? 'month' : ( scope.mode === 'month' ) ? 'year' : 'day';\r\n      };\r\n      scope.getWeekNumber = function(row) {\r\n        if ( scope.mode !== 'day' || ! scope.showWeekNumbers || row.length !== 7 ) {\r\n          return;\r\n        }\r\n\r\n        var index = ( startingDay > 4 ) ? 11 - startingDay : 4 - startingDay; // Thursday\r\n        var d = new Date( row[ index ].date );\r\n        d.setHours(0, 0, 0);\r\n        return Math.ceil((((d - new Date(d.getFullYear(), 0, 1)) / 86400000) + 1) / 7); // 86400000 = 1000*60*60*24;\r\n      };\r\n    }\r\n  };\r\n}]);\r\n// The `$dialogProvider` can be used to configure global defaults for your\r\n// `$dialog` service.\r\nvar dialogModule = angular.module('ui.bootstrap.dialog', ['ui.bootstrap.transition']);\r\n\r\ndialogModule.controller('MessageBoxController', ['$scope', 'dialog', 'model', function($scope, dialog, model){\r\n  $scope.title = model.title;\r\n  $scope.message = model.message;\r\n  $scope.buttons = model.buttons;\r\n  $scope.close = function(res){\r\n    dialog.close(res);\r\n  };\r\n}]);\r\n\r\ndialogModule.provider(\"$dialog\", function(){\r\n\r\n  // The default options for all dialogs.\r\n  var defaults = {\r\n    backdrop: true,\r\n    dialogClass: 'modal',\r\n    backdropClass: 'modal-backdrop',\r\n    transitionClass: 'fade',\r\n    triggerClass: 'in',\r\n    resolve:{},\r\n    backdropFade: false,\r\n    dialogFade:false,\r\n    keyboard: true, // close with esc key\r\n    backdropClick: true // only in conjunction with backdrop=true\r\n    /* other options: template, templateUrl, controller */\r\n    };\r\n\r\n\tvar globalOptions = {};\r\n\r\n  var activeBackdrops = {value : 0};\r\n\r\n  // The `options({})` allows global configuration of all dialogs in the application.\r\n  //\r\n  //      var app = angular.module('App', ['ui.bootstrap.dialog'], function($dialogProvider){\r\n  //        // don't close dialog when backdrop is clicked by default\r\n  //        $dialogProvider.options({backdropClick: false});\r\n  //      });\r\n\tthis.options = function(value){\r\n\t\tglobalOptions = value;\r\n\t};\r\n\r\n  // Returns the actual `$dialog` service that is injected in controllers\r\n\tthis.$get = [\"$http\", \"$document\", \"$compile\", \"$rootScope\", \"$controller\", \"$templateCache\", \"$q\", \"$transition\", \"$injector\",\r\n  function ($http, $document, $compile, $rootScope, $controller, $templateCache, $q, $transition, $injector) {\r\n\r\n\t\tvar body = $document.find('body');\r\n\r\n\t\tfunction createElement(clazz) {\r\n\t\t\tvar el = angular.element(\"<div>\");\r\n\t\t\tel.addClass(clazz);\r\n\t\t\treturn el;\r\n\t\t}\r\n\r\n    // The `Dialog` class represents a modal dialog. The dialog class can be invoked by providing an options object\r\n    // containing at lest template or templateUrl and controller:\r\n    //\r\n    //     var d = new Dialog({templateUrl: 'foo.html', controller: 'BarController'});\r\n    //\r\n    // Dialogs can also be created using templateUrl and controller as distinct arguments:\r\n    //\r\n    //     var d = new Dialog('path/to/dialog.html', MyDialogController);\r\n\t\tfunction Dialog(opts) {\r\n\r\n      var self = this, options = this.options = angular.extend({}, defaults, globalOptions, opts);\r\n      this._open = false;\r\n\r\n      this.backdropEl = createElement(options.backdropClass);\r\n      if(options.backdropFade){\r\n        this.backdropEl.addClass(options.transitionClass);\r\n        this.backdropEl.removeClass(options.triggerClass);\r\n      }\r\n\r\n      this.modalEl = createElement(options.dialogClass);\r\n      if(options.dialogFade){\r\n        this.modalEl.addClass(options.transitionClass);\r\n        this.modalEl.removeClass(options.triggerClass);\r\n      }\r\n\r\n      this.handledEscapeKey = function(e) {\r\n        if (e.which === 27) {\r\n          self.close();\r\n          e.preventDefault();\r\n          self.$scope.$apply();\r\n        }\r\n      };\r\n\r\n      this.handleBackDropClick = function(e) {\r\n        self.close();\r\n        e.preventDefault();\r\n        self.$scope.$apply();\r\n      };\r\n\r\n      this.handleLocationChange = function() {\r\n        self.close();\r\n      };\r\n    }\r\n\r\n    // The `isOpen()` method returns wether the dialog is currently visible.\r\n    Dialog.prototype.isOpen = function(){\r\n      return this._open;\r\n    };\r\n\r\n    // The `open(templateUrl, controller)` method opens the dialog.\r\n    // Use the `templateUrl` and `controller` arguments if specifying them at dialog creation time is not desired.\r\n    Dialog.prototype.open = function(templateUrl, controller){\r\n      var self = this, options = this.options;\r\n\r\n      if(templateUrl){\r\n        options.templateUrl = templateUrl;\r\n      }\r\n      if(controller){\r\n        options.controller = controller;\r\n      }\r\n\r\n      if(!(options.template || options.templateUrl)) {\r\n        throw new Error('Dialog.open expected template or templateUrl, neither found. Use options or open method to specify them.');\r\n      }\r\n\r\n      this._loadResolves().then(function(locals) {\r\n        var $scope = locals.$scope = self.$scope = locals.$scope ? locals.$scope : $rootScope.$new();\r\n\r\n        self.modalEl.html(locals.$template);\r\n\r\n        if (self.options.controller) {\r\n          var ctrl = $controller(self.options.controller, locals);\r\n          self.modalEl.children().data('ngControllerController', ctrl);\r\n        }\r\n\r\n        $compile(self.modalEl)($scope);\r\n        self._addElementsToDom();\r\n\r\n        // trigger tranisitions\r\n        setTimeout(function(){\r\n          if(self.options.dialogFade){ self.modalEl.addClass(self.options.triggerClass); }\r\n          if(self.options.backdropFade){ self.backdropEl.addClass(self.options.triggerClass); }\r\n        });\r\n\r\n        self._bindEvents();\r\n      });\r\n\r\n      this.deferred = $q.defer();\r\n      return this.deferred.promise;\r\n    };\r\n\r\n    // closes the dialog and resolves the promise returned by the `open` method with the specified result.\r\n    Dialog.prototype.close = function(result){\r\n      var self = this;\r\n      var fadingElements = this._getFadingElements();\r\n\r\n      if(fadingElements.length > 0){\r\n        for (var i = fadingElements.length - 1; i >= 0; i--) {\r\n          $transition(fadingElements[i], removeTriggerClass).then(onCloseComplete);\r\n        }\r\n        return;\r\n      }\r\n\r\n      this._onCloseComplete(result);\r\n\r\n      function removeTriggerClass(el){\r\n        el.removeClass(self.options.triggerClass);\r\n      }\r\n\r\n      function onCloseComplete(){\r\n        if(self._open){\r\n          self._onCloseComplete(result);\r\n        }\r\n      }\r\n    };\r\n\r\n    Dialog.prototype._getFadingElements = function(){\r\n      var elements = [];\r\n      if(this.options.dialogFade){\r\n        elements.push(this.modalEl);\r\n      }\r\n      if(this.options.backdropFade){\r\n        elements.push(this.backdropEl);\r\n      }\r\n\r\n      return elements;\r\n    };\r\n\r\n    Dialog.prototype._bindEvents = function() {\r\n      if(this.options.keyboard){ body.bind('keydown', this.handledEscapeKey); }\r\n      if(this.options.backdrop && this.options.backdropClick){ this.backdropEl.bind('click', this.handleBackDropClick); }\r\n    };\r\n\r\n    Dialog.prototype._unbindEvents = function() {\r\n      if(this.options.keyboard){ body.unbind('keydown', this.handledEscapeKey); }\r\n      if(this.options.backdrop && this.options.backdropClick){ this.backdropEl.unbind('click', this.handleBackDropClick); }\r\n    };\r\n\r\n    Dialog.prototype._onCloseComplete = function(result) {\r\n      this._removeElementsFromDom();\r\n      this._unbindEvents();\r\n\r\n      this.deferred.resolve(result);\r\n    };\r\n\r\n    Dialog.prototype._addElementsToDom = function(){\r\n      body.append(this.modalEl);\r\n\r\n      if(this.options.backdrop) { \r\n        if (activeBackdrops.value === 0) {\r\n          body.append(this.backdropEl); \r\n        }\r\n        activeBackdrops.value++;\r\n      }\r\n\r\n      this._open = true;\r\n    };\r\n\r\n    Dialog.prototype._removeElementsFromDom = function(){\r\n      this.modalEl.remove();\r\n\r\n      if(this.options.backdrop) { \r\n        activeBackdrops.value--;\r\n        if (activeBackdrops.value === 0) {\r\n          this.backdropEl.remove(); \r\n        }\r\n      }\r\n      this._open = false;\r\n    };\r\n\r\n    // Loads all `options.resolve` members to be used as locals for the controller associated with the dialog.\r\n    Dialog.prototype._loadResolves = function(){\r\n      var values = [], keys = [], templatePromise, self = this;\r\n\r\n      if (this.options.template) {\r\n        templatePromise = $q.when(this.options.template);\r\n      } else if (this.options.templateUrl) {\r\n        templatePromise = $http.get(this.options.templateUrl, {cache:$templateCache})\r\n        .then(function(response) { return response.data; });\r\n      }\r\n\r\n      angular.forEach(this.options.resolve || [], function(value, key) {\r\n        keys.push(key);\r\n        values.push(angular.isString(value) ? $injector.get(value) : $injector.invoke(value));\r\n      });\r\n\r\n      keys.push('$template');\r\n      values.push(templatePromise);\r\n\r\n      return $q.all(values).then(function(values) {\r\n        var locals = {};\r\n        angular.forEach(values, function(value, index) {\r\n          locals[keys[index]] = value;\r\n        });\r\n        locals.dialog = self;\r\n        return locals;\r\n      });\r\n    };\r\n\r\n    // The actual `$dialog` service that is injected in controllers.\r\n    return {\r\n      // Creates a new `Dialog` with the specified options.\r\n      dialog: function(opts){\r\n        return new Dialog(opts);\r\n      },\r\n      // creates a new `Dialog` tied to the default message box template and controller.\r\n      //\r\n      // Arguments `title` and `message` are rendered in the modal header and body sections respectively.\r\n      // The `buttons` array holds an object with the following members for each button to include in the\r\n      // modal footer section:\r\n      //\r\n      // * `result`: the result to pass to the `close` method of the dialog when the button is clicked\r\n      // * `label`: the label of the button\r\n      // * `cssClass`: additional css class(es) to apply to the button for styling\r\n      messageBox: function(title, message, buttons){\r\n        return new Dialog({templateUrl: 'template/dialog/message.html', controller: 'MessageBoxController', resolve:\r\n          {model: function() {\r\n            return {\r\n              title: title,\r\n              message: message,\r\n              buttons: buttons\r\n            };\r\n          }\r\n        }});\r\n      }\r\n    };\r\n  }];\r\n});\r\n\r\n/*\r\n * dropdownToggle - Provides dropdown menu functionality in place of bootstrap js\r\n * @restrict class or attribute\r\n * @example:\r\n   <li class=\"dropdown\">\r\n     <a class=\"dropdown-toggle\">My Dropdown Menu</a>\r\n     <ul class=\"dropdown-menu\">\r\n       <li ng-repeat=\"choice in dropChoices\">\r\n         <a ng-href=\"{{choice.href}}\">{{choice.text}}</a>\r\n       </li>\r\n     </ul>\r\n   </li>\r\n */\r\n\r\nangular.module('ui.bootstrap.dropdownToggle', []).directive('dropdownToggle', ['$document', '$location', function ($document, $location) {\r\n  var openElement = null,\r\n      closeMenu   = angular.noop;\r\n  return {\r\n    restrict: 'CA',\r\n    link: function(scope, element, attrs) {\r\n      scope.$watch('$location.path', function() { closeMenu(); });\r\n      element.parent().bind('click', function() { closeMenu(); });\r\n      element.bind('click', function (event) {\r\n\r\n        var elementWasOpen = (element === openElement);\r\n\r\n        event.preventDefault();\r\n        event.stopPropagation();\r\n\r\n        if (!!openElement) {\r\n          closeMenu();\r\n        }\r\n\r\n        if (!elementWasOpen) {\r\n          element.parent().addClass('open');\r\n          openElement = element;\r\n          closeMenu = function (event) {\r\n            if (event) {\r\n              event.preventDefault();\r\n              event.stopPropagation();\r\n            }\r\n            $document.unbind('click', closeMenu);\r\n            element.parent().removeClass('open');\r\n            closeMenu = angular.noop;\r\n            openElement = null;\r\n          };\r\n          $document.bind('click', closeMenu);\r\n        }\r\n      });\r\n    }\r\n  };\r\n}]);\r\nangular.module('ui.bootstrap.modal', ['ui.bootstrap.dialog'])\r\n.directive('modal', ['$parse', '$dialog', function($parse, $dialog) {\r\n  return {\r\n    restrict: 'EA',\r\n    terminal: true,\r\n    link: function(scope, elm, attrs) {\r\n      var opts = angular.extend({}, scope.$eval(attrs.uiOptions || attrs.bsOptions || attrs.options));\r\n      var shownExpr = attrs.modal || attrs.show;\r\n      var setClosed;\r\n\r\n      // Create a dialog with the template as the contents of the directive\r\n      // Add the current scope as the resolve in order to make the directive scope as a dialog controller scope\r\n      opts = angular.extend(opts, {\r\n        template: elm.html(), \r\n        resolve: { $scope: function() { return scope; } }\r\n      });\r\n      var dialog = $dialog.dialog(opts);\r\n\r\n      elm.remove();\r\n\r\n      if (attrs.close) {\r\n        setClosed = function() {\r\n          $parse(attrs.close)(scope);\r\n        };\r\n      } else {\r\n        setClosed = function() {         \r\n          if (angular.isFunction($parse(shownExpr).assign)) {\r\n            $parse(shownExpr).assign(scope, false); \r\n          }\r\n        };\r\n      }\r\n\r\n      scope.$watch(shownExpr, function(isShown, oldShown) {\r\n        if (isShown) {\r\n          dialog.open().then(function(){\r\n            setClosed();\r\n          });\r\n        } else {\r\n          //Make sure it is not opened\r\n          if (dialog.isOpen()){\r\n            dialog.close();\r\n          }\r\n        }\r\n      });\r\n    }\r\n  };\r\n}]);\r\nangular.module('ui.bootstrap.pagination', [])\r\n\r\n.controller('PaginationController', ['$scope', function (scope) {\r\n\r\n  scope.noPrevious = function() {\r\n    return scope.currentPage === 1;\r\n  };\r\n  scope.noNext = function() {\r\n    return scope.currentPage === scope.numPages;\r\n  };\r\n\r\n  scope.isActive = function(page) {\r\n    return scope.currentPage === page;\r\n  };\r\n\r\n  scope.selectPage = function(page) {\r\n    if ( ! scope.isActive(page) && page > 0 && page <= scope.numPages) {\r\n      scope.currentPage = page;\r\n      scope.onSelectPage({ page: page });\r\n    }\r\n  };\r\n}])\r\n\r\n.constant('paginationConfig', {\r\n  boundaryLinks: false,\r\n  directionLinks: true,\r\n  firstText: 'First',\r\n  previousText: 'Previous',\r\n  nextText: 'Next',\r\n  lastText: 'Last',\r\n  rotate: true\r\n})\r\n\r\n.directive('pagination', ['paginationConfig', function(paginationConfig) {\r\n  return {\r\n    restrict: 'EA',\r\n    scope: {\r\n      numPages: '=',\r\n      currentPage: '=',\r\n      maxSize: '=',\r\n      onSelectPage: '&'\r\n    },\r\n    controller: 'PaginationController',\r\n    templateUrl: 'template/pagination/pagination.html',\r\n    replace: true,\r\n    link: function(scope, element, attrs) {\r\n\r\n      // Setup configuration parameters\r\n      var boundaryLinks = angular.isDefined(attrs.boundaryLinks) ? scope.$eval(attrs.boundaryLinks) : paginationConfig.boundaryLinks;\r\n      var directionLinks = angular.isDefined(attrs.directionLinks) ? scope.$eval(attrs.directionLinks) : paginationConfig.directionLinks;\r\n      var firstText = angular.isDefined(attrs.firstText) ? scope.$parent.$eval(attrs.firstText) : paginationConfig.firstText;\r\n      var previousText = angular.isDefined(attrs.previousText) ? scope.$parent.$eval(attrs.previousText) : paginationConfig.previousText;\r\n      var nextText = angular.isDefined(attrs.nextText) ? scope.$parent.$eval(attrs.nextText) : paginationConfig.nextText;\r\n      var lastText = angular.isDefined(attrs.lastText) ? scope.$parent.$eval(attrs.lastText) : paginationConfig.lastText;\r\n      var rotate = angular.isDefined(attrs.rotate) ? scope.$eval(attrs.rotate) : paginationConfig.rotate;\r\n\r\n      // Create page object used in template\r\n      function makePage(number, text, isActive, isDisabled) {\r\n        return {\r\n          number: number,\r\n          text: text,\r\n          active: isActive,\r\n          disabled: isDisabled\r\n        };\r\n      }\r\n\r\n      scope.$watch('numPages + currentPage + maxSize', function() {\r\n        scope.pages = [];\r\n        \r\n        // Default page limits\r\n        var startPage = 1, endPage = scope.numPages;\r\n        var isMaxSized = ( angular.isDefined(scope.maxSize) && scope.maxSize < scope.numPages );\r\n\r\n        // recompute if maxSize\r\n        if ( isMaxSized ) {\r\n          if ( rotate ) {\r\n            // Current page is displayed in the middle of the visible ones\r\n            startPage = Math.max(scope.currentPage - Math.floor(scope.maxSize/2), 1);\r\n            endPage   = startPage + scope.maxSize - 1;\r\n\r\n            // Adjust if limit is exceeded\r\n            if (endPage > scope.numPages) {\r\n              endPage   = scope.numPages;\r\n              startPage = endPage - scope.maxSize + 1;\r\n            }\r\n          } else {\r\n            // Visible pages are paginated with maxSize\r\n            startPage = ((Math.ceil(scope.currentPage / scope.maxSize) - 1) * scope.maxSize) + 1;\r\n\r\n            // Adjust last page if limit is exceeded\r\n            endPage = Math.min(startPage + scope.maxSize - 1, scope.numPages);\r\n          }\r\n        }\r\n\r\n        // Add page number links\r\n        for (var number = startPage; number <= endPage; number++) {\r\n          var page = makePage(number, number, scope.isActive(number), false);\r\n          scope.pages.push(page);\r\n        }\r\n\r\n        // Add links to move between page sets\r\n        if ( isMaxSized && ! rotate ) {\r\n          if ( startPage > 1 ) {\r\n            var previousPageSet = makePage(startPage - 1, '...', false, false);\r\n            scope.pages.unshift(previousPageSet);\r\n          }\r\n\r\n          if ( endPage < scope.numPages ) {\r\n            var nextPageSet = makePage(endPage + 1, '...', false, false);\r\n            scope.pages.push(nextPageSet);\r\n          }\r\n        }\r\n\r\n        // Add previous & next links\r\n        if (directionLinks) {\r\n          var previousPage = makePage(scope.currentPage - 1, previousText, false, scope.noPrevious());\r\n          scope.pages.unshift(previousPage);\r\n\r\n          var nextPage = makePage(scope.currentPage + 1, nextText, false, scope.noNext());\r\n          scope.pages.push(nextPage);\r\n        }\r\n\r\n        // Add first & last links\r\n        if (boundaryLinks) {\r\n          var firstPage = makePage(1, firstText, false, scope.noPrevious());\r\n          scope.pages.unshift(firstPage);\r\n\r\n          var lastPage = makePage(scope.numPages, lastText, false, scope.noNext());\r\n          scope.pages.push(lastPage);\r\n        }\r\n\r\n        if ( scope.currentPage > scope.numPages ) {\r\n          scope.selectPage(scope.numPages);\r\n        }\r\n      });\r\n    }\r\n  };\r\n}])\r\n\r\n.constant('pagerConfig', {\r\n  previousText: 'Ã‚Â« Previous',\r\n  nextText: 'Next Ã‚Â»',\r\n  align: true\r\n})\r\n\r\n.directive('pager', ['pagerConfig', function(config) {\r\n  return {\r\n    restrict: 'EA',\r\n    scope: {\r\n      numPages: '=',\r\n      currentPage: '=',\r\n      onSelectPage: '&'\r\n    },\r\n    controller: 'PaginationController',\r\n    templateUrl: 'template/pagination/pager.html',\r\n    replace: true,\r\n    link: function(scope, element, attrs, paginationCtrl) {\r\n\r\n      // Setup configuration parameters\r\n      var previousText = angular.isDefined(attrs.previousText) ? scope.$parent.$eval(attrs.previousText) : config.previousText;\r\n      var nextText = angular.isDefined(attrs.nextText) ? scope.$parent.$eval(attrs.nextText) : config.nextText;\r\n      var align = angular.isDefined(attrs.align) ? scope.$parent.$eval(attrs.align) : config.align;\r\n\r\n      // Create page object used in template\r\n      function makePage(number, text, isDisabled, isPrevious, isNext) {\r\n        return {\r\n          number: number,\r\n          text: text,\r\n          disabled: isDisabled,\r\n          previous: ( align && isPrevious ),\r\n          next: ( align && isNext )\r\n        };\r\n      }\r\n\r\n      scope.$watch('numPages + currentPage', function() {\r\n        scope.pages = [];\r\n\r\n        // Add previous & next links\r\n        var previousPage = makePage(scope.currentPage - 1, previousText, scope.noPrevious(), true, false);\r\n        scope.pages.unshift(previousPage);\r\n\r\n        var nextPage = makePage(scope.currentPage + 1, nextText, scope.noNext(), false, true);\r\n        scope.pages.push(nextPage);\r\n\r\n        if ( scope.currentPage > scope.numPages ) {\r\n          scope.selectPage(scope.numPages);\r\n        }\r\n      });\r\n    }\r\n  };\r\n}]);\r\n\r\nangular.module('ui.bootstrap.position', [])\r\n\r\n/**\r\n * A set of utility methods that can be use to retrieve position of DOM elements.\r\n * It is meant to be used where we need to absolute-position DOM elements in\r\n * relation to other, existing elements (this is the case for tooltips, popovers,\r\n * typeahead suggestions etc.).\r\n */\r\n  .factory('$position', ['$document', '$window', function ($document, $window) {\r\n\r\n    var mouseX, mouseY;\r\n\r\n    $document.bind('mousemove', function mouseMoved(event) {\r\n      mouseX = event.pageX;\r\n      mouseY = event.pageY;\r\n    });\r\n\r\n    function getStyle(el, cssprop) {\r\n      if (el.currentStyle) { //IE\r\n        return el.currentStyle[cssprop];\r\n      } else if ($window.getComputedStyle) {\r\n        return $window.getComputedStyle(el)[cssprop];\r\n      }\r\n      // finally try and get inline style\r\n      return el.style[cssprop];\r\n    }\r\n\r\n    /**\r\n     * Checks if a given element is statically positioned\r\n     * @param element - raw DOM element\r\n     */\r\n    function isStaticPositioned(element) {\r\n      return (getStyle(element, \"position\") || 'static' ) === 'static';\r\n    }\r\n\r\n    /**\r\n     * returns the closest, non-statically positioned parentOffset of a given element\r\n     * @param element\r\n     */\r\n    var parentOffsetEl = function (element) {\r\n      var docDomEl = $document[0];\r\n      var offsetParent = element.offsetParent || docDomEl;\r\n      while (offsetParent && offsetParent !== docDomEl && isStaticPositioned(offsetParent) ) {\r\n        offsetParent = offsetParent.offsetParent;\r\n      }\r\n      return offsetParent || docDomEl;\r\n    };\r\n\r\n    return {\r\n      /**\r\n       * Provides read-only equivalent of jQuery's position function:\r\n       * http://api.jquery.com/position/\r\n       */\r\n      position: function (element) {\r\n        var elBCR = this.offset(element);\r\n        var offsetParentBCR = { top: 0, left: 0 };\r\n        var offsetParentEl = parentOffsetEl(element[0]);\r\n        if (offsetParentEl != $document[0]) {\r\n          offsetParentBCR = this.offset(angular.element(offsetParentEl));\r\n          offsetParentBCR.top += offsetParentEl.clientTop;\r\n          offsetParentBCR.left += offsetParentEl.clientLeft;\r\n        }\r\n\r\n        return {\r\n          width: element.prop('offsetWidth'),\r\n          height: element.prop('offsetHeight'),\r\n          top: elBCR.top - offsetParentBCR.top,\r\n          left: elBCR.left - offsetParentBCR.left\r\n        };\r\n      },\r\n\r\n      /**\r\n       * Provides read-only equivalent of jQuery's offset function:\r\n       * http://api.jquery.com/offset/\r\n       */\r\n      offset: function (element) {\r\n        var boundingClientRect = element[0].getBoundingClientRect();\r\n        return {\r\n          width: element.prop('offsetWidth'),\r\n          height: element.prop('offsetHeight'),\r\n          top: boundingClientRect.top + ($window.pageYOffset || $document[0].body.scrollTop),\r\n          left: boundingClientRect.left + ($window.pageXOffset || $document[0].body.scrollLeft)\r\n        };\r\n      },\r\n\r\n      /**\r\n       * Provides the coordinates of the mouse\r\n       */\r\n      mouse: function () {\r\n        return {x: mouseX, y: mouseY};\r\n      }\r\n    };\r\n  }]);\r\n\r\n/**\r\n * The following features are still outstanding: animation as a\r\n * function, placement as a function, inside, support for more triggers than\r\n * just mouse enter/leave, html tooltips, and selector delegation.\r\n */\r\nangular.module( 'ui.bootstrap.tooltip', [ 'ui.bootstrap.position' ] )\r\n\r\n/**\r\n * The $tooltip service creates tooltip- and popover-like directives as well as\r\n * houses global options for them.\r\n */\r\n.provider( '$tooltip', function () {\r\n  // The default options tooltip and popover.\r\n  var defaultOptions = {\r\n    placement: 'top',\r\n    animation: true,\r\n    popupDelay: 0\r\n  };\r\n\r\n  // Default hide triggers for each show trigger\r\n  var triggerMap = {\r\n    'mouseenter': 'mouseleave',\r\n    'click': 'click',\r\n    'focus': 'blur'\r\n  };\r\n\r\n  // The options specified to the provider globally.\r\n  var globalOptions = {};\r\n  \r\n  /**\r\n   * `options({})` allows global configuration of all tooltips in the\r\n   * application.\r\n   *\r\n   *   var app = angular.module( 'App', ['ui.bootstrap.tooltip'], function( $tooltipProvider ) {\r\n   *     // place tooltips left instead of top by default\r\n   *     $tooltipProvider.options( { placement: 'left' } );\r\n   *   });\r\n   */\r\n\tthis.options = function( value ) {\r\n\t\tangular.extend( globalOptions, value );\r\n\t};\r\n\r\n  /**\r\n   * This allows you to extend the set of trigger mappings available. E.g.:\r\n   *\r\n   *   $tooltipProvider.setTriggers( 'openTrigger': 'closeTrigger' );\r\n   */\r\n  this.setTriggers = function setTriggers ( triggers ) {\r\n    angular.extend( triggerMap, triggers );\r\n  };\r\n\r\n  /**\r\n   * This is a helper function for translating camel-case to snake-case.\r\n   */\r\n  function snake_case(name){\r\n    var regexp = /[A-Z]/g;\r\n    var separator = '-';\r\n    return name.replace(regexp, function(letter, pos) {\r\n      return (pos ? separator : '') + letter.toLowerCase();\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Returns the actual instance of the $tooltip service.\r\n   * TODO support multiple triggers\r\n   */\r\n  this.$get = [ '$window', '$compile', '$timeout', '$parse', '$document', '$position', '$interpolate', function ( $window, $compile, $timeout, $parse, $document, $position, $interpolate ) {\r\n    return function $tooltip ( type, prefix, defaultTriggerShow ) {\r\n      var options = angular.extend( {}, defaultOptions, globalOptions );\r\n\r\n      /**\r\n       * Returns an object of show and hide triggers.\r\n       *\r\n       * If a trigger is supplied,\r\n       * it is used to show the tooltip; otherwise, it will use the `trigger`\r\n       * option passed to the `$tooltipProvider.options` method; else it will\r\n       * default to the trigger supplied to this directive factory.\r\n       *\r\n       * The hide trigger is based on the show trigger. If the `trigger` option\r\n       * was passed to the `$tooltipProvider.options` method, it will use the\r\n       * mapped trigger from `triggerMap` or the passed trigger if the map is\r\n       * undefined; otherwise, it uses the `triggerMap` value of the show\r\n       * trigger; else it will just use the show trigger.\r\n       */\r\n      function setTriggers ( trigger ) {\r\n        var show, hide;\r\n       \r\n        show = trigger || options.trigger || defaultTriggerShow;\r\n        if ( angular.isDefined ( options.trigger ) ) {\r\n          hide = triggerMap[options.trigger] || show;\r\n        } else {\r\n          hide = triggerMap[show] || show;\r\n        }\r\n\r\n        return {\r\n          show: show,\r\n          hide: hide\r\n        };\r\n      }\r\n\r\n      var directiveName = snake_case( type );\r\n      var triggers = setTriggers( undefined );\r\n\r\n      var startSym = $interpolate.startSymbol();\r\n      var endSym = $interpolate.endSymbol();\r\n      var template = \r\n        '<'+ directiveName +'-popup '+\r\n          'title=\"'+startSym+'tt_title'+endSym+'\" '+\r\n          'content=\"'+startSym+'tt_content'+endSym+'\" '+\r\n          'placement=\"'+startSym+'tt_placement'+endSym+'\" '+\r\n          'animation=\"tt_animation()\" '+\r\n          'is-open=\"tt_isOpen\"'+\r\n          '>'+\r\n        '</'+ directiveName +'-popup>';\r\n\r\n      return {\r\n        restrict: 'EA',\r\n        scope: true,\r\n        link: function link ( scope, element, attrs ) {\r\n          var tooltip = $compile( template )( scope );\r\n          var transitionTimeout;\r\n          var popupTimeout;\r\n          var $body;\r\n          var appendToBody = angular.isDefined( options.appendToBody ) ? options.appendToBody : false;\r\n\r\n          // By default, the tooltip is not open.\r\n          // TODO add ability to start tooltip opened\r\n          scope.tt_isOpen = false;\r\n\r\n          function toggleTooltipBind () {\r\n            if ( ! scope.tt_isOpen ) {\r\n              showTooltipBind();\r\n            } else {\r\n              hideTooltipBind();\r\n            }\r\n          }\r\n          \r\n          // Show the tooltip with delay if specified, otherwise show it immediately\r\n          function showTooltipBind() {\r\n            if ( scope.tt_popupDelay ) {\r\n              popupTimeout = $timeout( show, scope.tt_popupDelay );\r\n            } else {\r\n              scope.$apply( show );\r\n            }\r\n          }\r\n\r\n          function hideTooltipBind () {\r\n            scope.$apply(function () {\r\n              hide();\r\n            });\r\n          }\r\n          \r\n          // Show the tooltip popup element.\r\n          function show() {\r\n            var position,\r\n                ttWidth,\r\n                ttHeight,\r\n                ttPosition;\r\n\r\n            // Don't show empty tooltips.\r\n            if ( ! scope.tt_content ) {\r\n              return;\r\n            }\r\n\r\n            // If there is a pending remove transition, we must cancel it, lest the\r\n            // tooltip be mysteriously removed.\r\n            if ( transitionTimeout ) {\r\n              $timeout.cancel( transitionTimeout );\r\n            }\r\n            \r\n            // Set the initial positioning.\r\n            tooltip.css({ top: 0, left: 0, display: 'block' });\r\n            \r\n            // Now we add it to the DOM because need some info about it. But it's not \r\n            // visible yet anyway.\r\n            if ( appendToBody ) {\r\n                $body = $body || $document.find( 'body' );\r\n                $body.append( tooltip );\r\n            } else {\r\n              element.after( tooltip );\r\n            }\r\n\r\n            // Get the position of the directive element.\r\n            position = options.appendToBody ? $position.offset( element ) : $position.position( element );\r\n\r\n            // Get the height and width of the tooltip so we can center it.\r\n            ttWidth = tooltip.prop( 'offsetWidth' );\r\n            ttHeight = tooltip.prop( 'offsetHeight' );\r\n            \r\n            // Calculate the tooltip's top and left coordinates to center it with\r\n            // this directive.\r\n            switch ( scope.tt_placement ) {\r\n              case 'mouse':\r\n                var mousePos = $position.mouse();\r\n                ttPosition = {\r\n                  top: mousePos.y,\r\n                  left: mousePos.x\r\n                };\r\n                break;\r\n              case 'right':\r\n                ttPosition = {\r\n                  top: position.top + position.height / 2 - ttHeight / 2,\r\n                  left: position.left + position.width\r\n                };\r\n                break;\r\n              case 'bottom':\r\n                ttPosition = {\r\n                  top: position.top + position.height,\r\n                  left: position.left + position.width / 2 - ttWidth / 2\r\n                };\r\n                break;\r\n              case 'left':\r\n                ttPosition = {\r\n                  top: position.top + position.height / 2 - ttHeight / 2,\r\n                  left: position.left - ttWidth\r\n                };\r\n                break;\r\n              default:\r\n                ttPosition = {\r\n                  top: position.top - ttHeight,\r\n                  left: position.left + position.width / 2 - ttWidth / 2\r\n                };\r\n                break;\r\n            }\r\n\r\n            ttPosition.top += 'px';\r\n            ttPosition.left += 'px';\r\n\r\n            // Now set the calculated positioning.\r\n            tooltip.css( ttPosition );\r\n              \r\n            // And show the tooltip.\r\n            scope.tt_isOpen = true;\r\n          }\r\n          \r\n          // Hide the tooltip popup element.\r\n          function hide() {\r\n            // First things first: we don't show it anymore.\r\n            scope.tt_isOpen = false;\r\n\r\n            //if tooltip is going to be shown after delay, we must cancel this\r\n            $timeout.cancel( popupTimeout );\r\n            \r\n            // And now we remove it from the DOM. However, if we have animation, we \r\n            // need to wait for it to expire beforehand.\r\n            // FIXME: this is a placeholder for a port of the transitions library.\r\n            if ( angular.isDefined( scope.tt_animation ) && scope.tt_animation() ) {\r\n              transitionTimeout = $timeout( function () { tooltip.remove(); }, 500 );\r\n            } else {\r\n              tooltip.remove();\r\n            }\r\n          }\r\n\r\n          /**\r\n           * Observe the relevant attributes.\r\n           */\r\n          attrs.$observe( type, function ( val ) {\r\n            scope.tt_content = val;\r\n          });\r\n\r\n          attrs.$observe( prefix+'Title', function ( val ) {\r\n            scope.tt_title = val;\r\n          });\r\n\r\n          attrs.$observe( prefix+'Placement', function ( val ) {\r\n            scope.tt_placement = angular.isDefined( val ) ? val : options.placement;\r\n          });\r\n\r\n          attrs.$observe( prefix+'Animation', function ( val ) {\r\n            scope.tt_animation = angular.isDefined( val ) ? $parse( val ) : function(){ return options.animation; };\r\n          });\r\n\r\n          attrs.$observe( prefix+'PopupDelay', function ( val ) {\r\n            var delay = parseInt( val, 10 );\r\n            scope.tt_popupDelay = ! isNaN(delay) ? delay : options.popupDelay;\r\n          });\r\n\r\n          attrs.$observe( prefix+'Trigger', function ( val ) {\r\n            element.unbind( triggers.show );\r\n            element.unbind( triggers.hide );\r\n\r\n            triggers = setTriggers( val );\r\n\r\n            if ( triggers.show === triggers.hide ) {\r\n              element.bind( triggers.show, toggleTooltipBind );\r\n            } else {\r\n              element.bind( triggers.show, showTooltipBind );\r\n              element.bind( triggers.hide, hideTooltipBind );\r\n            }\r\n          });\r\n\r\n          attrs.$observe( prefix+'AppendToBody', function ( val ) {\r\n            appendToBody = angular.isDefined( val ) ? $parse( val )( scope ) : appendToBody;\r\n          });\r\n\r\n          // if a tooltip is attached to <body> we need to remove it on\r\n          // location change as its parent scope will probably not be destroyed\r\n          // by the change.\r\n          if ( appendToBody ) {\r\n            scope.$on('$locationChangeSuccess', function closeTooltipOnLocationChangeSuccess () {\r\n            if ( scope.tt_isOpen ) {\r\n              hide();\r\n            }\r\n          });\r\n          }\r\n\r\n          // Make sure tooltip is destroyed and removed.\r\n          scope.$on('$destroy', function onDestroyTooltip() {\r\n            if ( scope.tt_isOpen ) {\r\n              hide();\r\n            } else {\r\n              tooltip.remove();\r\n            }\r\n          });\r\n        }\r\n      };\r\n    };\r\n  }];\r\n})\r\n\r\n.directive( 'tooltipPopup', function () {\r\n  return {\r\n    restrict: 'E',\r\n    replace: true,\r\n    scope: { content: '@', placement: '@', animation: '&', isOpen: '&' },\r\n    templateUrl: 'template/tooltip/tooltip-popup.html'\r\n  };\r\n})\r\n\r\n.directive( 'tooltip', [ '$tooltip', function ( $tooltip ) {\r\n  return $tooltip( 'tooltip', 'tooltip', 'mouseenter' );\r\n}])\r\n\r\n.directive( 'tooltipHtmlUnsafePopup', function () {\r\n  return {\r\n    restrict: 'E',\r\n    replace: true,\r\n    scope: { content: '@', placement: '@', animation: '&', isOpen: '&' },\r\n    templateUrl: 'template/tooltip/tooltip-html-unsafe-popup.html'\r\n  };\r\n})\r\n\r\n.directive( 'tooltipHtmlUnsafe', [ '$tooltip', function ( $tooltip ) {\r\n  return $tooltip( 'tooltipHtmlUnsafe', 'tooltip', 'mouseenter' );\r\n}]);\r\n\r\n/**\r\n * The following features are still outstanding: popup delay, animation as a\r\n * function, placement as a function, inside, support for more triggers than\r\n * just mouse enter/leave, html popovers, and selector delegatation.\r\n */\r\nangular.module( 'ui.bootstrap.popover', [ 'ui.bootstrap.tooltip' ] )\r\n.directive( 'popoverPopup', function () {\r\n  return {\r\n    restrict: 'EA',\r\n    replace: true,\r\n    scope: { title: '@', content: '@', placement: '@', animation: '&', isOpen: '&' },\r\n    templateUrl: 'template/popover/popover.html'\r\n  };\r\n})\r\n.directive( 'popover', [ '$compile', '$timeout', '$parse', '$window', '$tooltip', function ( $compile, $timeout, $parse, $window, $tooltip ) {\r\n  return $tooltip( 'popover', 'popover', 'click' );\r\n}]);\r\n\r\n\r\nangular.module('ui.bootstrap.progressbar', ['ui.bootstrap.transition'])\r\n\r\n.constant('progressConfig', {\r\n  animate: true,\r\n  autoType: false,\r\n  stackedTypes: ['success', 'info', 'warning', 'danger']\r\n})\r\n\r\n.controller('ProgressBarController', ['$scope', '$attrs', 'progressConfig', function($scope, $attrs, progressConfig) {\r\n\r\n    // Whether bar transitions should be animated\r\n    var animate = angular.isDefined($attrs.animate) ? $scope.$eval($attrs.animate) : progressConfig.animate;\r\n    var autoType = angular.isDefined($attrs.autoType) ? $scope.$eval($attrs.autoType) : progressConfig.autoType;\r\n    var stackedTypes = angular.isDefined($attrs.stackedTypes) ? $scope.$eval('[' + $attrs.stackedTypes + ']') : progressConfig.stackedTypes;\r\n\r\n    // Create bar object\r\n    this.makeBar = function(newBar, oldBar, index) {\r\n        var newValue = (angular.isObject(newBar)) ? newBar.value : (newBar || 0);\r\n        var oldValue =  (angular.isObject(oldBar)) ? oldBar.value : (oldBar || 0);\r\n        var type = (angular.isObject(newBar) && angular.isDefined(newBar.type)) ? newBar.type : (autoType) ? getStackedType(index || 0) : null;\r\n\r\n        return {\r\n            from: oldValue,\r\n            to: newValue,\r\n            type: type,\r\n            animate: animate\r\n        };\r\n    };\r\n\r\n    function getStackedType(index) {\r\n        return stackedTypes[index];\r\n    }\r\n\r\n    this.addBar = function(bar) {\r\n        $scope.bars.push(bar);\r\n        $scope.totalPercent += bar.to;\r\n    };\r\n\r\n    this.clearBars = function() {\r\n        $scope.bars = [];\r\n        $scope.totalPercent = 0;\r\n    };\r\n    this.clearBars();\r\n}])\r\n\r\n.directive('progress', function() {\r\n    return {\r\n        restrict: 'EA',\r\n        replace: true,\r\n        controller: 'ProgressBarController',\r\n        scope: {\r\n            value: '=percent',\r\n            onFull: '&',\r\n            onEmpty: '&'\r\n        },\r\n        templateUrl: 'template/progressbar/progress.html',\r\n        link: function(scope, element, attrs, controller) {\r\n            scope.$watch('value', function(newValue, oldValue) {\r\n                controller.clearBars();\r\n\r\n                if (angular.isArray(newValue)) {\r\n                    // Stacked progress bar\r\n                    for (var i=0, n=newValue.length; i < n; i++) {\r\n                        controller.addBar(controller.makeBar(newValue[i], oldValue[i], i));\r\n                    }\r\n                } else {\r\n                    // Simple bar\r\n                    controller.addBar(controller.makeBar(newValue, oldValue));\r\n                }\r\n            }, true);\r\n\r\n            // Total percent listeners\r\n            scope.$watch('totalPercent', function(value) {\r\n              if (value >= 100) {\r\n                scope.onFull();\r\n              } else if (value <= 0) {\r\n                scope.onEmpty();\r\n              }\r\n            }, true);\r\n        }\r\n    };\r\n})\r\n\r\n.directive('progressbar', ['$transition', function($transition) {\r\n    return {\r\n        restrict: 'EA',\r\n        replace: true,\r\n        scope: {\r\n            width: '=',\r\n            old: '=',\r\n            type: '=',\r\n            animate: '='\r\n        },\r\n        templateUrl: 'template/progressbar/bar.html',\r\n        link: function(scope, element) {\r\n            scope.$watch('width', function(value) {\r\n                if (scope.animate) {\r\n                    element.css('width', scope.old + '%');\r\n                    $transition(element, {width: value + '%'});\r\n                } else {\r\n                    element.css('width', value + '%');\r\n                }\r\n            });\r\n        }\r\n    };\r\n}]);\r\nangular.module('ui.bootstrap.rating', [])\r\n\r\n.constant('ratingConfig', {\r\n  max: 5\r\n})\r\n\r\n.directive('rating', ['ratingConfig', '$parse', function(ratingConfig, $parse) {\r\n  return {\r\n    restrict: 'EA',\r\n    scope: {\r\n      value: '='\r\n    },\r\n    templateUrl: 'template/rating/rating.html',\r\n    replace: true,\r\n    link: function(scope, element, attrs) {\r\n\r\n      var maxRange = angular.isDefined(attrs.max) ? scope.$eval(attrs.max) : ratingConfig.max;\r\n\r\n      scope.range = [];\r\n      for (var i = 1; i <= maxRange; i++) {\r\n          scope.range.push(i);\r\n      }\r\n\r\n      scope.rate = function(value) {\r\n          if ( ! scope.readonly ) {\r\n              scope.value = value;\r\n          }\r\n      };\r\n\r\n      scope.enter = function(value) {\r\n          if ( ! scope.readonly ) {\r\n              scope.val = value;\r\n          }\r\n      };\r\n\r\n      scope.reset = function() {\r\n          scope.val = angular.copy(scope.value);\r\n      };\r\n      scope.reset();\r\n\r\n      scope.$watch('value', function(value) {\r\n          scope.val = value;\r\n      });\r\n\r\n      scope.readonly = false;\r\n      if (attrs.readonly) {\r\n          scope.$parent.$watch($parse(attrs.readonly), function(value) {\r\n              scope.readonly = !!value;\r\n          });\r\n      }\r\n    }\r\n  };\r\n}]);\r\n\r\n/**\r\n * @ngdoc overview\r\n * @name ui.bootstrap.tabs\r\n *\r\n * @description\r\n * AngularJS version of the tabs directive.\r\n */\r\n\r\nangular.module('ui.bootstrap.tabs', [])\r\n\r\n.directive('tabs', function() {\r\n  return function() {\r\n    throw new Error(\"The `tabs` directive is deprecated, please migrate to `tabset`. Instructions can be found at http://github.com/angular-ui/bootstrap/tree/master/CHANGELOG.md\");\r\n  };\r\n})\r\n\r\n.controller('TabsetController', ['$scope', '$element', \r\nfunction TabsetCtrl($scope, $element) {\r\n  var ctrl = this,\r\n    tabs = ctrl.tabs = $scope.tabs = [];\r\n\r\n  ctrl.select = function(tab) {\r\n    angular.forEach(tabs, function(tab) {\r\n      tab.active = false;\r\n    });  \r\n    tab.active = true;\r\n  };\r\n\r\n  ctrl.addTab = function addTab(tab) {\r\n    tabs.push(tab);\r\n    if (tabs.length == 1) {\r\n      ctrl.select(tab);\r\n    }\r\n  };\r\n\r\n  ctrl.removeTab = function removeTab(tab) { \r\n    var index = tabs.indexOf(tab);\r\n    //Select a new tab if the tab to be removed is selected\r\n    if (tab.active && tabs.length > 1) {\r\n      //If this is the last tab, select the previous tab. else, the next tab.\r\n      var newActiveIndex = index == tabs.length - 1 ? index - 1 : index + 1;\r\n      ctrl.select(tabs[newActiveIndex]);\r\n    }\r\n    tabs.splice(index, 1);\r\n  };\r\n}])\r\n\r\n/**\r\n * @ngdoc directive\r\n * @name ui.bootstrap.tabs.directive:tabset\r\n * @restrict EA\r\n *\r\n * @description\r\n * Tabset is the outer container for the tabs directive\r\n *\r\n * @param {boolean=} vertical Whether or not to use vertical styling for the tabs.\r\n *\r\n * @example\r\n<example module=\"ui.bootstrap\">\r\n  <file name=\"index.html\">\r\n    <tabset>\r\n      <tab heading=\"Vertical Tab 1\"><b>First</b> Content!</tab>\r\n      <tab heading=\"Vertical Tab 2\"><i>Second</i> Content!</tab>\r\n    </tabset>\r\n    <hr />\r\n    <tabset vertical=\"true\">\r\n      <tab heading=\"Vertical Tab 1\"><b>First</b> Vertical Content!</tab>\r\n      <tab heading=\"Vertical Tab 2\"><i>Second</i> Vertical Content!</tab>\r\n    </tabset>\r\n  </file>\r\n</example>\r\n */\r\n.directive('tabset', function() {\r\n  return {\r\n    restrict: 'EA',\r\n    transclude: true,\r\n    scope: {},\r\n    controller: 'TabsetController',\r\n    templateUrl: 'template/tabs/tabset.html',\r\n    link: function(scope, element, attrs) {\r\n      scope.vertical = angular.isDefined(attrs.vertical) ? scope.$eval(attrs.vertical) : false;\r\n      scope.type = angular.isDefined(attrs.type) ? scope.$parent.$eval(attrs.type) : 'tabs';\r\n    }\r\n  };\r\n})\r\n\r\n/**\r\n * @ngdoc directive\r\n * @name ui.bootstrap.tabs.directive:tab\r\n * @restrict EA\r\n *\r\n * @param {string=} heading The visible heading, or title, of the tab. Set HTML headings with {@link ui.bootstrap.tabs.directive:tabHeading tabHeading}.\r\n * @param {string=} select An expression to evaluate when the tab is selected.\r\n * @param {boolean=} active A binding, telling whether or not this tab is selected.\r\n * @param {boolean=} disabled A binding, telling whether or not this tab is disabled.\r\n *\r\n * @description \r\n * Creates a tab with a heading and content. Must be placed within a {@link ui.bootstrap.tabs.directive:tabset tabset}.\r\n *\r\n * @example\r\n<example module=\"ui.bootstrap\">\r\n  <file name=\"index.html\">\r\n    <div ng-controller=\"TabsDemoCtrl\">\r\n      <button class=\"btn btn-small\" ng-click=\"items[0].active = true\">\r\n        Select item 1, using active binding\r\n      </button>\r\n      <button class=\"btn btn-small\" ng-click=\"items[1].disabled = !items[1].disabled\">\r\n        Enable/disable item 2, using disabled binding\r\n      </button>\r\n      <br />\r\n      <tabset>\r\n        <tab heading=\"Tab 1\">First Tab</tab>\r\n        <tab select=\"alertMe()\">\r\n          <tab-heading><i class=\"icon-bell\"></i> Alert me!</tab-heading>\r\n          Second Tab, with alert callback and html heading!\r\n        </tab>\r\n        <tab ng-repeat=\"item in items\"\r\n          heading=\"{{item.title}}\"\r\n          disabled=\"item.disabled\"\r\n          active=\"item.active\">\r\n          {{item.content}}\r\n        </tab>\r\n      </tabset>\r\n    </div>\r\n  </file>\r\n  <file name=\"script.js\">\r\n    function TabsDemoCtrl($scope) {\r\n      $scope.items = [\r\n        { title:\"Dynamic Title 1\", content:\"Dynamic Item 0\" },\r\n        { title:\"Dynamic Title 2\", content:\"Dynamic Item 1\", disabled: true }\r\n      ];\r\n\r\n      $scope.alertMe = function() {\r\n        setTimeout(function() {\r\n          alert(\"You've selected the alert tab!\");\r\n        });\r\n      };\r\n    };\r\n  </file>\r\n</example>\r\n */\r\n\r\n/**\r\n * @ngdoc directive\r\n * @name ui.bootstrap.tabs.directive:tabHeading\r\n * @restrict EA\r\n *\r\n * @description\r\n * Creates an HTML heading for a {@link ui.bootstrap.tabs.directive:tab tab}. Must be placed as a child of a tab element.\r\n *\r\n * @example\r\n<example module=\"ui.bootstrap\">\r\n  <file name=\"index.html\">\r\n    <tabset>\r\n      <tab>\r\n        <tab-heading><b>HTML</b> in my titles?!</tab-heading>\r\n        And some content, too!\r\n      </tab>\r\n      <tab>\r\n        <tab-heading><i class=\"icon-heart\"></i> Icon heading?!?</tab-heading>\r\n        That's right.\r\n      </tab>\r\n    </tabset>\r\n  </file>\r\n</example>\r\n */\r\n.directive('tab', ['$parse', '$http', '$templateCache', '$compile',\r\nfunction($parse, $http, $templateCache, $compile) {\r\n  return {\r\n    require: '^tabset',\r\n    restrict: 'EA',\r\n    replace: true,\r\n    templateUrl: 'template/tabs/tab.html',\r\n    transclude: true,\r\n    scope: {\r\n      heading: '@',\r\n      onSelect: '&select' //This callback is called in contentHeadingTransclude\r\n                          //once it inserts the tab's content into the dom\r\n    },\r\n    controller: function() {\r\n      //Empty controller so other directives can require being 'under' a tab\r\n    },\r\n    compile: function(elm, attrs, transclude) {\r\n      return function postLink(scope, elm, attrs, tabsetCtrl) {\r\n        var getActive, setActive;\r\n        scope.active = false; // default value\r\n        if (attrs.active) {\r\n          getActive = $parse(attrs.active);\r\n          setActive = getActive.assign;\r\n          scope.$parent.$watch(getActive, function updateActive(value) {\r\n            if ( !!value && scope.disabled ) {\r\n              setActive(scope.$parent, false); // Prevent active assignment\r\n            } else {\r\n              scope.active = !!value;\r\n            }\r\n          });\r\n        } else {\r\n          setActive = getActive = angular.noop;\r\n        }\r\n\r\n        scope.$watch('active', function(active) {\r\n          setActive(scope.$parent, active);\r\n          if (active) {\r\n            tabsetCtrl.select(scope);\r\n            scope.onSelect();\r\n          }\r\n        });\r\n\r\n        scope.disabled = false;\r\n        if ( attrs.disabled ) {\r\n          scope.$parent.$watch($parse(attrs.disabled), function(value) {\r\n            scope.disabled = !! value;\r\n          });\r\n        }\r\n\r\n        scope.select = function() {\r\n          if ( ! scope.disabled ) {\r\n            scope.active = true;\r\n          }\r\n        };\r\n\r\n        tabsetCtrl.addTab(scope);\r\n        scope.$on('$destroy', function() {\r\n          tabsetCtrl.removeTab(scope);\r\n        });\r\n        //If the tabset sets this tab to active, set the parent scope's active\r\n        //binding too.  We do this so the watch for the parent's initial active\r\n        //value won't overwrite what is initially set by the tabset\r\n        if (scope.active) {\r\n          setActive(scope.$parent, true);\r\n        } \r\n\r\n        //Transclude the collection of sibling elements. Use forEach to find\r\n        //the heading if it exists. We don't use a directive for tab-heading\r\n        //because it is problematic. Discussion @ http://git.io/MSNPwQ\r\n        transclude(scope.$parent, function(clone) {\r\n          //Look at every element in the clone collection. If it's tab-heading,\r\n          //mark it as that.  If it's not tab-heading, mark it as tab contents\r\n          var contents = [], heading;\r\n          angular.forEach(clone, function(el) {\r\n            //See if it's a tab-heading attr or element directive\r\n            //First make sure it's a normal element, one that has a tagName\r\n            if (el.tagName &&\r\n                (el.hasAttribute(\"tab-heading\") || \r\n                 el.hasAttribute(\"data-tab-heading\") ||\r\n                 el.tagName.toLowerCase() == \"tab-heading\" ||\r\n                 el.tagName.toLowerCase() == \"data-tab-heading\"\r\n                )) {\r\n              heading = el;\r\n            } else {\r\n              contents.push(el);\r\n            }\r\n          });\r\n          //Share what we found on the scope, so our tabHeadingTransclude and\r\n          //tabContentTransclude directives can find out what the heading and\r\n          //contents are.\r\n          if (heading) { \r\n            scope.headingElement = angular.element(heading);\r\n          }\r\n          scope.contentElement = angular.element(contents);\r\n        });\r\n      };\r\n    }\r\n  };\r\n}])\r\n\r\n.directive('tabHeadingTransclude', [function() {\r\n  return {\r\n    restrict: 'A',\r\n    require: '^tab', \r\n    link: function(scope, elm, attrs, tabCtrl) {\r\n      scope.$watch('headingElement', function updateHeadingElement(heading) {\r\n        if (heading) {\r\n          elm.html('');\r\n          elm.append(heading);\r\n        }\r\n      });\r\n    }\r\n  };\r\n}])\r\n\r\n.directive('tabContentTransclude', ['$parse', function($parse) {\r\n  return {\r\n    restrict: 'A',\r\n    require: '^tabset',\r\n    link: function(scope, elm, attrs, tabsetCtrl) {\r\n      scope.$watch($parse(attrs.tabContentTransclude), function(tab) {\r\n        elm.html('');\r\n        if (tab) {\r\n          elm.append(tab.contentElement);\r\n        }\r\n      });\r\n    }\r\n  };\r\n}])\r\n\r\n;\r\n\r\n\r\nangular.module('ui.bootstrap.timepicker', [])\r\n\r\n.filter('pad', function() {\r\n  return function(input) {\r\n    if ( angular.isDefined(input) && input.toString().length < 2 ) {\r\n      input = '0' + input;\r\n    }\r\n    return input;\r\n  };\r\n})\r\n\r\n.constant('timepickerConfig', {\r\n  hourStep: 1,\r\n  minuteStep: 1,\r\n  showMeridian: true,\r\n  meridians: ['AM', 'PM'],\r\n  readonlyInput: false,\r\n  mousewheel: true\r\n})\r\n\r\n.directive('timepicker', ['padFilter', '$parse', 'timepickerConfig', function (padFilter, $parse, timepickerConfig) {\r\n  return {\r\n    restrict: 'EA',\r\n    require:'ngModel',\r\n    replace: true,\r\n    templateUrl: 'template/timepicker/timepicker.html',\r\n    scope: {\r\n        model: '=ngModel'\r\n    },\r\n    link: function(scope, element, attrs, ngModelCtrl) {\r\n      var selected = new Date(), meridians = timepickerConfig.meridians;\r\n\r\n      var hourStep = timepickerConfig.hourStep;\r\n      if (attrs.hourStep) {\r\n        scope.$parent.$watch($parse(attrs.hourStep), function(value) {\r\n          hourStep = parseInt(value, 10);\r\n        });\r\n      }\r\n\r\n      var minuteStep = timepickerConfig.minuteStep;\r\n      if (attrs.minuteStep) {\r\n        scope.$parent.$watch($parse(attrs.minuteStep), function(value) {\r\n          minuteStep = parseInt(value, 10);\r\n        });\r\n      }\r\n\r\n      // 12H / 24H mode\r\n      scope.showMeridian = timepickerConfig.showMeridian;\r\n      if (attrs.showMeridian) {\r\n        scope.$parent.$watch($parse(attrs.showMeridian), function(value) {\r\n          scope.showMeridian = !! value;\r\n\r\n          if ( ! scope.model ) {\r\n            // Reset\r\n            var dt = new Date( selected );\r\n            var hours = getScopeHours();\r\n            if (angular.isDefined( hours )) {\r\n              dt.setHours( hours );\r\n            }\r\n            scope.model = new Date( dt );\r\n          } else {\r\n            refreshTemplate();\r\n          }\r\n        });\r\n      }\r\n\r\n      // Get scope.hours in 24H mode if valid\r\n      function getScopeHours ( ) {\r\n        var hours = parseInt( scope.hours, 10 );\r\n        var valid = ( scope.showMeridian ) ? (hours > 0 && hours < 13) : (hours >= 0 && hours < 24);\r\n        if ( !valid ) {\r\n          return;\r\n        }\r\n\r\n        if ( scope.showMeridian ) {\r\n          if ( hours === 12 ) {\r\n            hours = 0;\r\n          }\r\n          if ( scope.meridian === meridians[1] ) {\r\n            hours = hours + 12;\r\n          }\r\n        }\r\n        return hours;\r\n      }\r\n\r\n      // Input elements\r\n      var inputs = element.find('input');\r\n      var hoursInputEl = inputs.eq(0), minutesInputEl = inputs.eq(1);\r\n\r\n      // Respond on mousewheel spin\r\n      var mousewheel = (angular.isDefined(attrs.mousewheel)) ? scope.$eval(attrs.mousewheel) : timepickerConfig.mousewheel;\r\n      if ( mousewheel ) {\r\n\r\n        var isScrollingUp = function(e) {\r\n          if (e.originalEvent) {\r\n            e = e.originalEvent;\r\n          }\r\n          return (e.detail || e.wheelDelta > 0);\r\n        };\r\n\r\n        hoursInputEl.bind('mousewheel', function(e) {\r\n          scope.$apply( (isScrollingUp(e)) ? scope.incrementHours() : scope.decrementHours() );\r\n          e.preventDefault();\r\n        });\r\n\r\n        minutesInputEl.bind('mousewheel', function(e) {\r\n          scope.$apply( (isScrollingUp(e)) ? scope.incrementMinutes() : scope.decrementMinutes() );\r\n          e.preventDefault();\r\n        });\r\n      }\r\n\r\n      var keyboardChange = false;\r\n      scope.readonlyInput = (angular.isDefined(attrs.readonlyInput)) ? scope.$eval(attrs.readonlyInput) : timepickerConfig.readonlyInput;\r\n      if ( ! scope.readonlyInput ) {\r\n        scope.updateHours = function() {\r\n          var hours = getScopeHours();\r\n\r\n          if ( angular.isDefined(hours) ) {\r\n              keyboardChange = 'h';\r\n              if ( scope.model === null ) {\r\n                 scope.model = new Date( selected );\r\n              }\r\n              scope.model.setHours( hours );\r\n          } else {\r\n              scope.model = null;\r\n              scope.validHours = false;\r\n          }\r\n        };\r\n\r\n        hoursInputEl.bind('blur', function(e) {\r\n          if ( scope.validHours && scope.hours < 10) {\r\n            scope.$apply( function() {\r\n              scope.hours = padFilter( scope.hours );\r\n            });\r\n          }\r\n        });\r\n\r\n        scope.updateMinutes = function() {\r\n          var minutes = parseInt(scope.minutes, 10);\r\n          if ( minutes >= 0 && minutes < 60 ) {\r\n            keyboardChange = 'm';\r\n            if ( scope.model === null ) {\r\n              scope.model = new Date( selected );\r\n            }\r\n            scope.model.setMinutes( minutes );\r\n          } else {\r\n            scope.model = null;\r\n            scope.validMinutes = false;\r\n          }\r\n        };\r\n\r\n        minutesInputEl.bind('blur', function(e) {\r\n          if ( scope.validMinutes && scope.minutes < 10 ) {\r\n            scope.$apply( function() {\r\n              scope.minutes = padFilter( scope.minutes );\r\n            });\r\n          }\r\n        });\r\n      } else {\r\n        scope.updateHours = angular.noop;\r\n        scope.updateMinutes = angular.noop;\r\n      }\r\n\r\n      scope.$watch( function getModelTimestamp() {\r\n        return +scope.model;\r\n      }, function( timestamp ) {\r\n        if ( !isNaN( timestamp ) && timestamp > 0 ) {\r\n          selected = new Date( timestamp );\r\n          refreshTemplate();\r\n        }\r\n      });\r\n\r\n      function refreshTemplate() {\r\n        var hours = selected.getHours();\r\n        if ( scope.showMeridian ) {\r\n          // Convert 24 to 12 hour system\r\n          hours = ( hours === 0 || hours === 12 ) ? 12 : hours % 12;\r\n        }\r\n        scope.hours =  ( keyboardChange === 'h' ) ? hours : padFilter(hours);\r\n        scope.validHours = true;\r\n\r\n        var minutes = selected.getMinutes();\r\n        scope.minutes = ( keyboardChange === 'm' ) ? minutes : padFilter(minutes);\r\n        scope.validMinutes = true;\r\n\r\n        scope.meridian = ( scope.showMeridian ) ? (( selected.getHours() < 12 ) ? meridians[0] : meridians[1]) : '';\r\n\r\n        keyboardChange = false;\r\n      }\r\n\r\n      function addMinutes( minutes ) {\r\n        var dt = new Date( selected.getTime() + minutes * 60000 );\r\n        if ( dt.getDate() !== selected.getDate()) {\r\n          dt.setDate( dt.getDate() - 1 );\r\n        }\r\n        selected.setTime( dt.getTime() );\r\n        scope.model = new Date( selected );\r\n      }\r\n\r\n      scope.incrementHours = function() {\r\n        addMinutes( hourStep * 60 );\r\n      };\r\n      scope.decrementHours = function() {\r\n        addMinutes( - hourStep * 60 );\r\n      };\r\n      scope.incrementMinutes = function() {\r\n        addMinutes( minuteStep );\r\n      };\r\n      scope.decrementMinutes = function() {\r\n        addMinutes( - minuteStep );\r\n      };\r\n      scope.toggleMeridian = function() {\r\n        addMinutes( 12 * 60 * (( selected.getHours() < 12 ) ? 1 : -1) );\r\n      };\r\n    }\r\n  };\r\n}]);\r\nangular.module('ui.bootstrap.typeahead', ['ui.bootstrap.position'])\r\n\r\n/**\r\n * A helper service that can parse typeahead's syntax (string provided by users)\r\n * Extracted to a separate service for ease of unit testing\r\n */\r\n  .factory('typeaheadParser', ['$parse', function ($parse) {\r\n\r\n  //                      00000111000000000000022200000000000000003333333333333330000000000044000\r\n  var TYPEAHEAD_REGEXP = /^\\s*(.*?)(?:\\s+as\\s+(.*?))?\\s+for\\s+(?:([\\$\\w][\\$\\w\\d]*))\\s+in\\s+(.*)$/;\r\n\r\n  return {\r\n    parse:function (input) {\r\n\r\n      var match = input.match(TYPEAHEAD_REGEXP), modelMapper, viewMapper, source;\r\n      if (!match) {\r\n        throw new Error(\r\n          \"Expected typeahead specification in form of '_modelValue_ (as _label_)? for _item_ in _collection_'\" +\r\n            \" but got '\" + input + \"'.\");\r\n      }\r\n\r\n      return {\r\n        itemName:match[3],\r\n        source:$parse(match[4]),\r\n        viewMapper:$parse(match[2] || match[1]),\r\n        modelMapper:$parse(match[1])\r\n      };\r\n    }\r\n  };\r\n}])\r\n\r\n  .directive('typeahead', ['$compile', '$parse', '$q', '$timeout', '$document', '$position', 'typeaheadParser', function ($compile, $parse, $q, $timeout, $document, $position, typeaheadParser) {\r\n\r\n  var HOT_KEYS = [9, 13, 27, 38, 40];\r\n\r\n  return {\r\n    require:'ngModel',\r\n    link:function (originalScope, element, attrs, modelCtrl) {\r\n\r\n      var selected;\r\n\r\n      //minimal no of characters that needs to be entered before typeahead kicks-in\r\n      var minSearch = originalScope.$eval(attrs.typeaheadMinLength) || 1;\r\n\r\n      //minimal wait time after last character typed before typehead kicks-in\r\n      var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0;\r\n\r\n      //expressions used by typeahead\r\n      var parserResult = typeaheadParser.parse(attrs.typeahead);\r\n\r\n      //should it restrict model values to the ones selected from the popup only?\r\n      var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false;\r\n\r\n      var isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop;\r\n\r\n      var onSelectCallback = $parse(attrs.typeaheadOnSelect);\r\n\r\n      //pop-up element used to display matches\r\n      var popUpEl = angular.element('<typeahead-popup></typeahead-popup>');\r\n      popUpEl.attr({\r\n        matches: 'matches',\r\n        active: 'activeIdx',\r\n        select: 'select(activeIdx)',\r\n        query: 'query',\r\n        position: 'position'\r\n      });\r\n\r\n      //create a child scope for the typeahead directive so we are not polluting original scope\r\n      //with typeahead-specific data (matches, query etc.)\r\n      var scope = originalScope.$new();\r\n      originalScope.$on('$destroy', function(){\r\n        scope.$destroy();\r\n      });\r\n\r\n      var resetMatches = function() {\r\n        scope.matches = [];\r\n        scope.activeIdx = -1;\r\n      };\r\n\r\n      var getMatchesAsync = function(inputValue) {\r\n\r\n        var locals = {$viewValue: inputValue};\r\n        isLoadingSetter(originalScope, true);\r\n        $q.when(parserResult.source(scope, locals)).then(function(matches) {\r\n\r\n          //it might happen that several async queries were in progress if a user were typing fast\r\n          //but we are interested only in responses that correspond to the current view value\r\n          if (inputValue === modelCtrl.$viewValue) {\r\n            if (matches.length > 0) {\r\n\r\n              scope.activeIdx = 0;\r\n              scope.matches.length = 0;\r\n\r\n              //transform labels\r\n              for(var i=0; i<matches.length; i++) {\r\n                locals[parserResult.itemName] = matches[i];\r\n                scope.matches.push({\r\n                  label: parserResult.viewMapper(scope, locals),\r\n                  model: matches[i]\r\n                });\r\n              }\r\n\r\n              scope.query = inputValue;\r\n              //position pop-up with matches - we need to re-calculate its position each time we are opening a window\r\n              //with matches as a pop-up might be absolute-positioned and position of an input might have changed on a page\r\n              //due to other elements being rendered\r\n              scope.position = $position.position(element);\r\n              scope.position.top = scope.position.top + element.prop('offsetHeight');\r\n\r\n            } else {\r\n              resetMatches();\r\n            }\r\n            isLoadingSetter(originalScope, false);\r\n          }\r\n        }, function(){\r\n          resetMatches();\r\n          isLoadingSetter(originalScope, false);\r\n        });\r\n      };\r\n\r\n      resetMatches();\r\n\r\n      //we need to propagate user's query so we can higlight matches\r\n      scope.query = undefined;\r\n\r\n      //plug into $parsers pipeline to open a typeahead on view changes initiated from DOM\r\n      //$parsers kick-in on all the changes coming from the view as well as manually triggered by $setViewValue\r\n      modelCtrl.$parsers.push(function (inputValue) {\r\n\r\n        var timeoutId;\r\n\r\n        resetMatches();\r\n        if (selected) {\r\n          return inputValue;\r\n        } else {\r\n          if (inputValue && inputValue.length >= minSearch) {\r\n            if (waitTime > 0) {\r\n              if (timeoutId) {\r\n                $timeout.cancel(timeoutId);//cancel previous timeout\r\n              }\r\n              timeoutId = $timeout(function () {\r\n                getMatchesAsync(inputValue);\r\n              }, waitTime);\r\n            } else {\r\n              getMatchesAsync(inputValue);\r\n            }\r\n          }\r\n        }\r\n\r\n        return isEditable ? inputValue : undefined;\r\n      });\r\n\r\n      modelCtrl.$render = function () {\r\n        var locals = {};\r\n        locals[parserResult.itemName] = selected || modelCtrl.$viewValue;\r\n        element.val(parserResult.viewMapper(scope, locals) || modelCtrl.$viewValue);\r\n        selected = undefined;\r\n      };\r\n\r\n      scope.select = function (activeIdx) {\r\n        //called from within the $digest() cycle\r\n        var locals = {};\r\n        var model, item;\r\n        locals[parserResult.itemName] = item = selected = scope.matches[activeIdx].model;\r\n\r\n        model = parserResult.modelMapper(scope, locals);\r\n        modelCtrl.$setViewValue(model);\r\n        modelCtrl.$render();\r\n        onSelectCallback(scope, {\r\n          $item: item,\r\n          $model: model,\r\n          $label: parserResult.viewMapper(scope, locals)\r\n        });\r\n\r\n        element[0].focus();\r\n      };\r\n\r\n      //bind keyboard events: arrows up(38) / down(40), enter(13) and tab(9), esc(27)\r\n      element.bind('keydown', function (evt) {\r\n\r\n        //typeahead is open and an \"interesting\" key was pressed\r\n        if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {\r\n          return;\r\n        }\r\n\r\n        evt.preventDefault();\r\n\r\n        if (evt.which === 40) {\r\n          scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length;\r\n          scope.$digest();\r\n\r\n        } else if (evt.which === 38) {\r\n          scope.activeIdx = (scope.activeIdx ? scope.activeIdx : scope.matches.length) - 1;\r\n          scope.$digest();\r\n\r\n        } else if (evt.which === 13 || evt.which === 9) {\r\n          scope.$apply(function () {\r\n            scope.select(scope.activeIdx);\r\n          });\r\n\r\n        } else if (evt.which === 27) {\r\n          evt.stopPropagation();\r\n\r\n          resetMatches();\r\n          scope.$digest();\r\n        }\r\n      });\r\n\r\n      $document.bind('click', function(){\r\n        resetMatches();\r\n        scope.$digest();\r\n      });\r\n\r\n      element.after($compile(popUpEl)(scope));\r\n    }\r\n  };\r\n\r\n}])\r\n\r\n  .directive('typeaheadPopup', function () {\r\n    return {\r\n      restrict:'E',\r\n      scope:{\r\n        matches:'=',\r\n        query:'=',\r\n        active:'=',\r\n        position:'=',\r\n        select:'&'\r\n      },\r\n      replace:true,\r\n      templateUrl:'template/typeahead/typeahead.html',\r\n      link:function (scope, element, attrs) {\r\n\r\n        scope.isOpen = function () {\r\n          return scope.matches.length > 0;\r\n        };\r\n\r\n        scope.isActive = function (matchIdx) {\r\n          return scope.active == matchIdx;\r\n        };\r\n\r\n        scope.selectActive = function (matchIdx) {\r\n          scope.active = matchIdx;\r\n        };\r\n\r\n        scope.selectMatch = function (activeIdx) {\r\n          scope.select({activeIdx:activeIdx});\r\n        };\r\n      }\r\n    };\r\n  })\r\n\r\n  .filter('typeaheadHighlight', function() {\r\n\r\n    function escapeRegexp(queryToEscape) {\r\n      return queryToEscape.replace(/([.?*+^$[\\]\\\\(){}|-])/g, \"\\\\$1\");\r\n    }\r\n\r\n    return function(matchItem, query) {\r\n      return query ? matchItem.replace(new RegExp(escapeRegexp(query), 'gi'), '<strong>$&</strong>') : query;\r\n    };\r\n  });\r\n\r\nangular.module(\"template/accordion/accordion-group.html\", []).run([\"$templateCache\", function($templateCache) {\r\n  $templateCache.put(\"template/accordion/accordion-group.html\",\r\n    \"<div class=\\\"accordion-group\\\">\\n\" +\r\n    \"  <div class=\\\"accordion-heading\\\" ><a class=\\\"accordion-toggle\\\" ng-click=\\\"isOpen = !isOpen\\\" accordion-transclude=\\\"heading\\\">{{heading}}</a></div>\\n\" +\r\n    \"  <div class=\\\"accordion-body\\\" collapse=\\\"!isOpen\\\">\\n\" +\r\n    \"    <div class=\\\"accordion-inner\\\" ng-transclude></div>  </div>\\n\" +\r\n    \"</div>\");\r\n}]);\r\n\r\nangular.module(\"template/accordion/accordion.html\", []).run([\"$templateCache\", function($templateCache) {\r\n  $templateCache.put(\"template/accordion/accordion.html\",\r\n    \"<div class=\\\"accordion\\\" ng-transclude></div>\");\r\n}]);\r\n\r\nangular.module(\"template/alert/alert.html\", []).run([\"$templateCache\", function($templateCache) {\r\n  $templateCache.put(\"template/alert/alert.html\",\r\n    \"<div class='alert' ng-class='type && \\\"alert-\\\" + type'>\\n\" +\r\n    \"    <button ng-show='closeable' type='button' class='close' ng-click='close()'>&times;</button>\\n\" +\r\n    \"    <div ng-transclude></div>\\n\" +\r\n    \"</div>\\n\" +\r\n    \"\");\r\n}]);\r\n\r\nangular.module(\"template/carousel/carousel.html\", []).run([\"$templateCache\", function($templateCache) {\r\n  $templateCache.put(\"template/carousel/carousel.html\",\r\n    \"<div ng-mouseenter=\\\"pause()\\\" ng-mouseleave=\\\"play()\\\" class=\\\"carousel\\\">\\n\" +\r\n    \"    <ol class=\\\"carousel-indicators\\\" ng-show=\\\"slides().length > 1\\\">\\n\" +\r\n    \"        <li ng-repeat=\\\"slide in slides()\\\" ng-class=\\\"{active: isActive(slide)}\\\" ng-click=\\\"select(slide)\\\"></li>\\n\" +\r\n    \"    </ol>\\n\" +\r\n    \"    <div class=\\\"carousel-inner\\\" ng-transclude></div>\\n\" +\r\n    \"    <a ng-click=\\\"prev()\\\" class=\\\"carousel-control left\\\" ng-show=\\\"slides().length > 1\\\">&lsaquo;</a>\\n\" +\r\n    \"    <a ng-click=\\\"next()\\\" class=\\\"carousel-control right\\\" ng-show=\\\"slides().length > 1\\\">&rsaquo;</a>\\n\" +\r\n    \"</div>\\n\" +\r\n    \"\");\r\n}]);\r\n\r\nangular.module(\"template/carousel/slide.html\", []).run([\"$templateCache\", function($templateCache) {\r\n  $templateCache.put(\"template/carousel/slide.html\",\r\n    \"<div ng-class=\\\"{\\n\" +\r\n    \"    'active': leaving || (active && !entering),\\n\" +\r\n    \"    'prev': (next || active) && direction=='prev',\\n\" +\r\n    \"    'next': (next || active) && direction=='next',\\n\" +\r\n    \"    'right': direction=='prev',\\n\" +\r\n    \"    'left': direction=='next'\\n\" +\r\n    \"  }\\\" class=\\\"item\\\" ng-transclude></div>\\n\" +\r\n    \"\");\r\n}]);\r\n\r\nangular.module(\"template/datepicker/datepicker.html\", []).run([\"$templateCache\", function($templateCache) {\r\n  $templateCache.put(\"template/datepicker/datepicker.html\",\r\n    \"<table class=\\\"well well-large\\\">\\n\" +\r\n    \"  <thead>\\n\" +\r\n    \"    <tr class=\\\"text-center\\\">\\n\" +\r\n    \"      <th><button class=\\\"btn pull-left\\\" ng-click=\\\"move(-1)\\\"><i class=\\\"icon-chevron-left\\\"></i></button></th>\\n\" +\r\n    \"      <th colspan=\\\"{{rows[0].length - 2 + showWeekNumbers}}\\\"><button class=\\\"btn btn-block\\\" ng-click=\\\"toggleMode()\\\"><strong>{{title}}</strong></button></th>\\n\" +\r\n    \"      <th><button class=\\\"btn pull-right\\\" ng-click=\\\"move(1)\\\"><i class=\\\"icon-chevron-right\\\"></i></button></th>\\n\" +\r\n    \"    </tr>\\n\" +\r\n    \"    <tr class=\\\"text-center\\\" ng-show=\\\"labels.length > 0\\\">\\n\" +\r\n    \"      <th ng-show=\\\"showWeekNumbers\\\">#</th>\\n\" +\r\n    \"      <th ng-repeat=\\\"label in labels\\\">{{label}}</th>\\n\" +\r\n    \"    </tr>\\n\" +\r\n    \"  </thead>\\n\" +\r\n    \"  <tbody>\\n\" +\r\n    \"    <tr ng-repeat=\\\"row in rows\\\">\\n\" +\r\n    \"      <td ng-show=\\\"showWeekNumbers\\\" class=\\\"text-center\\\"><em>{{ getWeekNumber(row) }}</em></td>\\n\" +\r\n    \"      <td ng-repeat=\\\"dt in row\\\" class=\\\"text-center\\\">\\n\" +\r\n    \"        <button style=\\\"width:100%;\\\" class=\\\"btn\\\" ng-class=\\\"{'btn-info': dt.isSelected}\\\" ng-click=\\\"select(dt.date)\\\" ng-disabled=\\\"dt.disabled\\\"><span ng-class=\\\"{muted: ! dt.isCurrent}\\\">{{dt.label}}</span></button>\\n\" +\r\n    \"      </td>\\n\" +\r\n    \"    </tr>\\n\" +\r\n    \"  </tbody>\\n\" +\r\n    \"</table>\\n\" +\r\n    \"\");\r\n}]);\r\n\r\nangular.module(\"template/dialog/message.html\", []).run([\"$templateCache\", function($templateCache) {\r\n  $templateCache.put(\"template/dialog/message.html\",\r\n    \"<div class=\\\"modal-header\\\">\\n\" +\r\n    \"\t<h3>{{ title }}</h3>\\n\" +\r\n    \"</div>\\n\" +\r\n    \"<div class=\\\"modal-body\\\">\\n\" +\r\n    \"\t<p>{{ message }}</p>\\n\" +\r\n    \"</div>\\n\" +\r\n    \"<div class=\\\"modal-footer\\\">\\n\" +\r\n    \"\t<button ng-repeat=\\\"btn in buttons\\\" ng-click=\\\"close(btn.result)\\\" class=\\\"btn\\\" ng-class=\\\"btn.cssClass\\\">{{ btn.label }}</button>\\n\" +\r\n    \"</div>\\n\" +\r\n    \"\");\r\n}]);\r\n\r\nangular.module(\"template/modal/backdrop.html\", []).run([\"$templateCache\", function($templateCache) {\r\n  $templateCache.put(\"template/modal/backdrop.html\",\r\n    \"<div class=\\\"modal-backdrop\\\"></div>\");\r\n}]);\r\n\r\nangular.module(\"template/modal/window.html\", []).run([\"$templateCache\", function($templateCache) {\r\n  $templateCache.put(\"template/modal/window.html\",\r\n    \"<div class=\\\"modal in\\\" ng-transclude></div>\");\r\n}]);\r\n\r\nangular.module(\"template/pagination/pager.html\", []).run([\"$templateCache\", function($templateCache) {\r\n  $templateCache.put(\"template/pagination/pager.html\",\r\n    \"<div class=\\\"pager\\\">\\n\" +\r\n    \"  <ul>\\n\" +\r\n    \"    <li ng-repeat=\\\"page in pages\\\" ng-class=\\\"{disabled: page.disabled, previous: page.previous, next: page.next}\\\"><a ng-click=\\\"selectPage(page.number)\\\">{{page.text}}</a></li>\\n\" +\r\n    \"  </ul>\\n\" +\r\n    \"</div>\\n\" +\r\n    \"\");\r\n}]);\r\n\r\nangular.module(\"template/pagination/pagination.html\", []).run([\"$templateCache\", function($templateCache) {\r\n  $templateCache.put(\"template/pagination/pagination.html\",\r\n    \"<div class=\\\"pagination\\\"><ul>\\n\" +\r\n    \"  <li ng-repeat=\\\"page in pages\\\" ng-class=\\\"{active: page.active, disabled: page.disabled}\\\"><a ng-click=\\\"selectPage(page.number)\\\">{{page.text}}</a></li>\\n\" +\r\n    \"  </ul>\\n\" +\r\n    \"</div>\\n\" +\r\n    \"\");\r\n}]);\r\n\r\nangular.module(\"template/tooltip/tooltip-html-unsafe-popup.html\", []).run([\"$templateCache\", function($templateCache) {\r\n  $templateCache.put(\"template/tooltip/tooltip-html-unsafe-popup.html\",\r\n    \"<div class=\\\"tooltip {{placement}}\\\" ng-class=\\\"{ in: isOpen(), fade: animation() }\\\">\\n\" +\r\n    \"  <div class=\\\"tooltip-arrow\\\"></div>\\n\" +\r\n    \"  <div class=\\\"tooltip-inner\\\" ng-bind-html-unsafe=\\\"content\\\"></div>\\n\" +\r\n    \"</div>\\n\" +\r\n    \"\");\r\n}]);\r\n\r\nangular.module(\"template/tooltip/tooltip-popup.html\", []).run([\"$templateCache\", function($templateCache) {\r\n  $templateCache.put(\"template/tooltip/tooltip-popup.html\",\r\n    \"<div class=\\\"tooltip {{placement}}\\\" ng-class=\\\"{ in: isOpen(), fade: animation() }\\\">\\n\" +\r\n    \"  <div class=\\\"tooltip-arrow\\\"></div>\\n\" +\r\n    \"  <div class=\\\"tooltip-inner\\\" ng-bind=\\\"content\\\"></div>\\n\" +\r\n    \"</div>\\n\" +\r\n    \"\");\r\n}]);\r\n\r\nangular.module(\"template/popover/popover.html\", []).run([\"$templateCache\", function($templateCache) {\r\n  $templateCache.put(\"template/popover/popover.html\",\r\n    \"<div class=\\\"popover {{placement}}\\\" ng-class=\\\"{ in: isOpen(), fade: animation() }\\\">\\n\" +\r\n    \"  <div class=\\\"arrow\\\"></div>\\n\" +\r\n    \"\\n\" +\r\n    \"  <div class=\\\"popover-inner\\\">\\n\" +\r\n    \"      <h3 class=\\\"popover-title\\\" ng-bind=\\\"title\\\" ng-show=\\\"title\\\"></h3>\\n\" +\r\n    \"      <div class=\\\"popover-content\\\" ng-bind=\\\"content\\\"></div>\\n\" +\r\n    \"  </div>\\n\" +\r\n    \"</div>\\n\" +\r\n    \"\");\r\n}]);\r\n\r\nangular.module(\"template/progressbar/bar.html\", []).run([\"$templateCache\", function($templateCache) {\r\n  $templateCache.put(\"template/progressbar/bar.html\",\r\n    \"<div class=\\\"bar\\\" ng-class='type && \\\"bar-\\\" + type'></div>\");\r\n}]);\r\n\r\nangular.module(\"template/progressbar/progress.html\", []).run([\"$templateCache\", function($templateCache) {\r\n  $templateCache.put(\"template/progressbar/progress.html\",\r\n    \"<div class=\\\"progress\\\"><progressbar ng-repeat=\\\"bar in bars\\\" width=\\\"bar.to\\\" old=\\\"bar.from\\\" animate=\\\"bar.animate\\\" type=\\\"bar.type\\\"></progressbar></div>\");\r\n}]);\r\n\r\nangular.module(\"template/rating/rating.html\", []).run([\"$templateCache\", function($templateCache) {\r\n  $templateCache.put(\"template/rating/rating.html\",\r\n    \"<span ng-mouseleave=\\\"reset()\\\">\\n\" +\r\n    \"\t<i ng-repeat=\\\"number in range\\\" ng-mouseenter=\\\"enter(number)\\\" ng-click=\\\"rate(number)\\\" ng-class=\\\"{'icon-star': number <= val, 'icon-star-empty': number > val}\\\"></i>\\n\" +\r\n    \"</span>\\n\" +\r\n    \"\");\r\n}]);\r\n\r\nangular.module(\"template/tabs/pane.html\", []).run([\"$templateCache\", function($templateCache) {\r\n  $templateCache.put(\"template/tabs/pane.html\",\r\n    \"<div class=\\\"tab-pane\\\" ng-class=\\\"{active: selected}\\\" ng-show=\\\"selected\\\" ng-transclude></div>\\n\" +\r\n    \"\");\r\n}]);\r\n\r\nangular.module(\"template/tabs/tab.html\", []).run([\"$templateCache\", function($templateCache) {\r\n  $templateCache.put(\"template/tabs/tab.html\",\r\n    \"<li ng-class=\\\"{active: active, disabled: disabled}\\\">\\n\" +\r\n    \"  <a ng-click=\\\"select()\\\" tab-heading-transclude>{{heading}}</a>\\n\" +\r\n    \"</li>\\n\" +\r\n    \"\");\r\n}]);\r\n\r\nangular.module(\"template/tabs/tabs.html\", []).run([\"$templateCache\", function($templateCache) {\r\n  $templateCache.put(\"template/tabs/tabs.html\",\r\n    \"<div class=\\\"tabbable\\\">\\n\" +\r\n    \"  <ul class=\\\"nav nav-tabs\\\">\\n\" +\r\n    \"    <li ng-repeat=\\\"pane in panes\\\" ng-class=\\\"{active:pane.selected}\\\">\\n\" +\r\n    \"      <a ng-click=\\\"select(pane)\\\">{{pane.heading}}</a>\\n\" +\r\n    \"    </li>\\n\" +\r\n    \"  </ul>\\n\" +\r\n    \"  <div class=\\\"tab-content\\\" ng-transclude></div>\\n\" +\r\n    \"</div>\\n\" +\r\n    \"\");\r\n}]);\r\n\r\nangular.module(\"template/tabs/tabset.html\", []).run([\"$templateCache\", function($templateCache) {\r\n  $templateCache.put(\"template/tabs/tabset.html\",\r\n    \"\\n\" +\r\n    \"<div class=\\\"tabbable\\\">\\n\" +\r\n    \"  <ul class=\\\"nav {{type && 'nav-' + type}}\\\" ng-class=\\\"{'nav-stacked': vertical}\\\" ng-transclude>\\n\" +\r\n    \"  </ul>\\n\" +\r\n    \"  <div class=\\\"tab-content\\\">\\n\" +\r\n    \"    <div class=\\\"tab-pane\\\" \\n\" +\r\n    \"         ng-repeat=\\\"tab in tabs\\\" \\n\" +\r\n    \"         ng-class=\\\"{active: tab.active}\\\"\\n\" +\r\n    \"         tab-content-transclude=\\\"tab\\\" tt=\\\"tab\\\">\\n\" +\r\n    \"    </div>\\n\" +\r\n    \"  </div>\\n\" +\r\n    \"</div>\\n\" +\r\n    \"\");\r\n}]);\r\n\r\nangular.module(\"template/timepicker/timepicker.html\", []).run([\"$templateCache\", function($templateCache) {\r\n  $templateCache.put(\"template/timepicker/timepicker.html\",\r\n    \"<table class=\\\"form-inline\\\">\\n\" +\r\n    \"\t<tr class=\\\"text-center\\\">\\n\" +\r\n    \"\t\t<td><a ng-click=\\\"incrementHours()\\\" class=\\\"btn btn-link\\\"><i class=\\\"icon-chevron-up\\\"></i></a></td>\\n\" +\r\n    \"\t\t<td>&nbsp;</td>\\n\" +\r\n    \"\t\t<td><a ng-click=\\\"incrementMinutes()\\\" class=\\\"btn btn-link\\\"><i class=\\\"icon-chevron-up\\\"></i></a></td>\\n\" +\r\n    \"\t\t<td ng-show=\\\"showMeridian\\\"></td>\\n\" +\r\n    \"\t</tr>\\n\" +\r\n    \"\t<tr>\\n\" +\r\n    \"\t\t<td class=\\\"control-group\\\" ng-class=\\\"{'error': !validHours}\\\"><input type=\\\"text\\\" ng-model=\\\"hours\\\" ng-change=\\\"updateHours()\\\" class=\\\"span1 text-center\\\" ng-mousewheel=\\\"incrementHours()\\\" ng-readonly=\\\"readonlyInput\\\" maxlength=\\\"2\\\" /></td>\\n\" +\r\n    \"\t\t<td>:</td>\\n\" +\r\n    \"\t\t<td class=\\\"control-group\\\" ng-class=\\\"{'error': !validMinutes}\\\"><input type=\\\"text\\\" ng-model=\\\"minutes\\\" ng-change=\\\"updateMinutes()\\\" class=\\\"span1 text-center\\\" ng-readonly=\\\"readonlyInput\\\" maxlength=\\\"2\\\"></td>\\n\" +\r\n    \"\t\t<td ng-show=\\\"showMeridian\\\"><button ng-click=\\\"toggleMeridian()\\\" class=\\\"btn text-center\\\">{{meridian}}</button></td>\\n\" +\r\n    \"\t</tr>\\n\" +\r\n    \"\t<tr class=\\\"text-center\\\">\\n\" +\r\n    \"\t\t<td><a ng-click=\\\"decrementHours()\\\" class=\\\"btn btn-link\\\"><i class=\\\"icon-chevron-down\\\"></i></a></td>\\n\" +\r\n    \"\t\t<td>&nbsp;</td>\\n\" +\r\n    \"\t\t<td><a ng-click=\\\"decrementMinutes()\\\" class=\\\"btn btn-link\\\"><i class=\\\"icon-chevron-down\\\"></i></a></td>\\n\" +\r\n    \"\t\t<td ng-show=\\\"showMeridian\\\"></td>\\n\" +\r\n    \"\t</tr>\\n\" +\r\n    \"</table>\");\r\n}]);\r\n\r\nangular.module(\"template/typeahead/typeahead.html\", []).run([\"$templateCache\", function($templateCache) {\r\n  $templateCache.put(\"template/typeahead/typeahead.html\",\r\n    \"<ul class=\\\"typeahead dropdown-menu\\\" ng-style=\\\"{display: isOpen()&&'block' || 'none', top: position.top+'px', left: position.left+'px'}\\\">\\n\" +\r\n    \"    <li ng-repeat=\\\"match in matches\\\" ng-class=\\\"{active: isActive($index) }\\\" ng-mouseenter=\\\"selectActive($index)\\\">\\n\" +\r\n    \"        <a tabindex=\\\"-1\\\" ng-click=\\\"selectMatch($index)\\\" ng-bind-html-unsafe=\\\"match.label | typeaheadHighlight:query\\\"></a>\\n\" +\r\n    \"    </li>\\n\" +\r\n    \"</ul>\");\r\n}]);"]],"start1":0,"start2":0,"length1":51172,"length2":112362}]],"length":112362,"saved":false}
